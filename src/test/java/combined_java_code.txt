

--- Start of file: model\AbstractEventTest.java ---

package model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.time.LocalDateTime;
import org.junit.Test;

/**
 * JUnit Test Case for {@link AbstractEvent} class. Tests the functionality which is shared both by
 * {@code RecurringEvent & SingleEvent}.
 */

public class AbstractEventTest {

  @Test
  public void getDescription() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "Test Description", "Room101", true);
    assertEquals("Test Description", event.getDescription());
  }

  @Test
  public void testGetSubject() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "Desc", "Room101", true);
    assertEquals("Meeting", event.getSubject());
  }

  @Test
  public void testGetStartDateTime() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "Desc", "Room101", true);
    assertEquals(start, event.getStartDateTime());
  }

  @Test
  public void testGetLocation() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "Desc", "Room101", true);
    assertEquals("Room101", event.getLocation());
  }

  @Test
  public void testIsPublic() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent eventTrue = new SingleEvent("Meeting", start, end, "Desc", "Room101", true);
    SingleEvent eventFalse = new SingleEvent("Meeting", start, end, "Desc", "Room101", false);
    assertTrue(eventTrue.isPublic());
    assertFalse(eventFalse.isPublic());
  }

  @Test
  public void testIsAutoDecline() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "Desc", "Room101", true);
    assertFalse(event.isAutoDecline());
  }

  @Test
  public void testSetAutoDecline() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "Desc", "Room101", true);
    event.setAutoDecline(true);
    assertTrue(event.isAutoDecline());
  }

  @Test
  public void testSetSubject() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "Desc", "Room101", true);
    event.setSubject("Team Meeting");
    assertEquals("Team Meeting", event.getSubject());
  }

  @Test
  public void testSetDescription() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "Desc", "Room101", true);
    event.setDescription("Updated Description");
    assertEquals("Updated Description", event.getDescription());
  }

  @Test
  public void testSetLocation() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "Desc", "Room101", true);
    event.setLocation("Room202");
    assertEquals("Room202", event.getLocation());
  }

  @Test
  public void testSetStartDateTime() throws InvalidDateException {
    LocalDateTime originalStart = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime newStart = LocalDateTime.of(2025, 3, 1, 8, 30);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", originalStart, end, "Desc", "Room101", true);
    event.setStartDateTime(newStart);
    assertEquals(newStart, event.getStartDateTime());
  }

  @Test
  public void testSetPublic() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "Desc", "Room101", true);

    assertTrue(event.isPublic());
    event.setPublic(false);
    assertFalse(event.isPublic());
  }

  @Test
  public void testGetEffectiveEndDateTime() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event1 = new SingleEvent("Meeting", start, end, "Desc", "Room101", true);
    assertEquals(end, event1.getEffectiveEndDateTime());

    SingleEvent event2 = new SingleEvent("Meeting", start, end, "Desc", "Room101", true);
    event2.setEndDateTime(null);
    LocalDateTime expected = start.toLocalDate().atTime(23, 59);
    assertEquals(expected, event2.getEffectiveEndDateTime());
  }

  @Test
  public void testSetEndDateTime() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime originalEnd = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, originalEnd, "Desc", "Room101", true);

    LocalDateTime newEnd = LocalDateTime.of(2025, 3, 1, 11, 0);
    event.setEndDateTime(newEnd);
    assertEquals(newEnd, event.getEffectiveEndDateTime());

    try {
      event.setEndDateTime(LocalDateTime.of(2025, 3, 1, 8, 0));
      fail("Expected InvalidDateException not thrown.");
    } catch (InvalidDateException e) {
      assertEquals("End date & time must be after start date & time.", e.getMessage());
    }
  }
}
--- End of file: model\AbstractEventTest.java ---


--- Start of file: model\CalendarContextTest.java ---

package model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNotSame;
import static org.junit.Assert.assertSame;

import java.time.DateTimeException;
import java.time.ZoneId;
import org.junit.Test;

/**
 * Tests for the {@link CalendarContext} class. Checks different scenarios such as Invalid
 * TimeZones, Empty Strings, Change of TimeZones etc.
 */
public class CalendarContextTest {

  @Test
  public void testGettersAndSetters() {
    CalendarContext context = new CalendarContext("InitialName", "America/New_York");
    assertEquals("InitialName", context.getName());
    assertEquals(ZoneId.of("America/New_York"), context.getTimezone());
    context.setName("UpdatedName");
    assertEquals("UpdatedName", context.getName());
    context.setTimezone("Europe/London");
    assertEquals(ZoneId.of("Europe/London"), context.getTimezone());
    assertNotNull(context.getCalendarModel());
    assertNotNull(context.getCalendarService());
  }

  @Test(expected = DateTimeException.class)
  public void testInvalidTimezoneThrowsException() {
    new CalendarContext("Test", "Invalid/Timezone");
  }

  @Test(expected = DateTimeException.class)
  public void testSetTimezoneInvalidValue() {
    CalendarContext context = new CalendarContext("Test", "America/New_York");
    context.setTimezone("Not/A_Timezone");
  }

  @Test
  public void testSetNameToEmptyString() {
    CalendarContext context = new CalendarContext("NonEmpty", "America/New_York");
    context.setName("");
    assertEquals("", context.getName());
  }

  @Test
  public void testTimezoneConversionNotNull() {
    CalendarContext context = new CalendarContext("CalTest", "Asia/Tokyo");
    assertNotNull(context.getTimezone());
    assertEquals(ZoneId.of("Asia/Tokyo"), context.getTimezone());
  }

  @Test
  public void testMultipleTimezoneChanges() {
    CalendarContext context = new CalendarContext("MultiTZ", "America/Los_Angeles");
    context.setTimezone("Europe/Berlin");
    assertEquals(ZoneId.of("Europe/Berlin"), context.getTimezone());
    context.setTimezone("Australia/Sydney");
    assertEquals(ZoneId.of("Australia/Sydney"), context.getTimezone());
    context.setTimezone("Africa/Cairo");
    assertEquals(ZoneId.of("Africa/Cairo"), context.getTimezone());
  }

  @Test
  public void testDistinctInstancesBetweenContexts() {
    CalendarContext context1 = new CalendarContext("Cal1", "America/New_York");
    CalendarContext context2 = new CalendarContext("Cal2", "Europe/London");
    assertNotSame(context1.getCalendarModel(), context2.getCalendarModel());
    assertNotSame(context1.getCalendarService(), context2.getCalendarService());
  }

  @Test
  public void testCalendarServiceConsistency() {
    CalendarContext context = new CalendarContext("Test", "America/New_York");
    assertSame(context.getCalendarService(), context.getCalendarService());
  }

  @Test
  public void testCalendarModelConsistency() {
    CalendarContext context = new CalendarContext("Test", "America/New_York");
    assertSame(context.getCalendarModel(), context.getCalendarModel());
  }

  @Test
  public void testCalendarModelServiceIntegrityAfterChanges() {
    CalendarContext context = new CalendarContext("IntegrityTest", "America/New_York");
    context.setName("IntegrityUpdated");
    context.setTimezone("Europe/Paris");
    assertNotNull(context.getCalendarModel());
    assertNotNull(context.getCalendarService());
  }
}
--- End of file: model\CalendarContextTest.java ---


--- Start of file: model\CalendarManagerTest.java ---

package model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import org.junit.Before;
import org.junit.Test;

/**
 * Unit tests for the {@link CalendarManager} class.
 */
public class CalendarManagerTest {

  private CalendarManager manager;

  @Before
  public void setUp() {
    manager = new CalendarManager();
  }

  @Test
  public void testAddAndGetCalendar() {
    ICalendarContext cal1 = new CalendarContext("Cal1", "America/New_York");
    assertTrue("Calendar should be added successfully.", manager.addCalendar(cal1));
    ICalendarContext fetched = manager.getCalendar("Cal1");
    assertNotNull("Calendar should be retrievable by name.", fetched);
    assertEquals("Cal1", fetched.getName());
  }

  @Test
  public void testAddDuplicateCalendar() {
    ICalendarContext cal1 = new CalendarContext("Cal1", "America/New_York");
    ICalendarContext cal2 = new CalendarContext("Cal1", "Europe/Paris");
    assertTrue("First calendar added successfully.", manager.addCalendar(cal1));
    assertFalse("Adding duplicate calendar should fail.", manager.addCalendar(cal2));
  }

  @Test
  public void testSetAndGetCurrentCalendar() {
    ICalendarContext cal1 = new CalendarContext("Cal1", "America/New_York");
    ICalendarContext cal2 = new CalendarContext("Cal2", "Europe/Paris");
    manager.addCalendar(cal1);
    manager.addCalendar(cal2);
    manager.setCurrentCalendar("Cal2");
    ICalendarContext current = manager.getCurrentCalendar();
    assertNotNull("Current calendar should not be null.", current);
    assertEquals("Cal2", current.getName());
  }

  @Test
  public void testRemoveCalendar() {
    ICalendarContext cal1 = new CalendarContext("Cal1", "America/New_York");
    manager.addCalendar(cal1);
    manager.removeCalendar("Cal1");
    assertNull("Calendar should be removed.", manager.getCalendar("Cal1"));
    assertNull("Current calendar should be null after removal.",
        manager.getCurrentCalendar());
  }

  @Test
  public void testSetCurrentCalendarNonExistent() {
    ICalendarContext cal1 = new CalendarContext("Cal1", "America/New_York");
    manager.addCalendar(cal1);
    manager.setCurrentCalendar("Cal1");
    ICalendarContext current = manager.getCurrentCalendar();
    assertNotNull("Current calendar should not be null.", current);
    manager.setCurrentCalendar("NonExistent");
    ICalendarContext stillCurrent = manager.getCurrentCalendar();
    assertEquals("Current calendar should remain unchanged when" +
            " non-existent calendar is specified.",
        "Cal1", stillCurrent.getName());
  }

  @Test
  public void testRemoveCalendarWhenMultipleExist() {
    ICalendarContext cal1 = new CalendarContext("Cal1", "America/New_York");
    ICalendarContext cal2 = new CalendarContext("Cal2", "Europe/Paris");
    manager.addCalendar(cal1);
    manager.addCalendar(cal2);
    manager.setCurrentCalendar("Cal2");
    manager.removeCalendar("Cal1");
    assertNull("Cal1 should be removed.", manager.getCalendar("Cal1"));
    assertNotNull("Current calendar should still exist.", manager.getCurrentCalendar());
    assertEquals("Cal2", manager.getCurrentCalendar().getName());
  }

  @Test
  public void testAddMultipleDifferentCalendars() {
    ICalendarContext cal1 = new CalendarContext("Work", "America/New_York");
    ICalendarContext cal2 = new CalendarContext("Personal", "Europe/Paris");
    ICalendarContext cal3 = new CalendarContext("Holidays", "Asia/Tokyo");

    assertTrue(manager.addCalendar(cal1));
    assertTrue(manager.addCalendar(cal2));
    assertTrue(manager.addCalendar(cal3));
    assertNotNull(manager.getCalendar("Work"));
    assertNotNull(manager.getCalendar("Personal"));
    assertNotNull(manager.getCalendar("Holidays"));
  }
}

--- End of file: model\CalendarManagerTest.java ---


--- Start of file: model\CalendarModelTest.java ---

package model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.junit.Before;
import org.junit.Test;

/**
 * Unit tests for the CalendarModel class to verify event handling and storing logic.
 */
public class CalendarModelTest {

  private CalendarModel calendar;

  @Before
  public void setUp() {
    calendar = new CalendarModel();
  }

  @Test
  public void testAddAndGetEvents() throws InvalidDateException, EventConflictException {
    LocalDateTime start1 = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end1 = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event1 = new SingleEvent("Meeting", start1, end1, "", "", true);
    calendar.addEvent(event1, false);

    LocalDate eventsDate = LocalDate.of(2025, 3, 1);
    List<Event> eventsOnDate = calendar.getEventsOn(eventsDate);
    assertEquals("There should be one event on the given date.", 1, eventsOnDate.size());
  }

  /**
   * Test that adding a conflicting event with autoDecline enabled throws an exception.
   */
  @Test
  public void testAutoDeclineConflict() throws InvalidDateException, EventConflictException {
    LocalDateTime start1 = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end1 = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event1 = new SingleEvent("Meeting", start1, end1, "", "", true);
    calendar.addEvent(event1, false);

    LocalDateTime start2 = LocalDateTime.of(2025, 3, 1, 9, 30);
    LocalDateTime end2 = LocalDateTime.of(2025, 3, 1, 10, 30);
    SingleEvent event2 = new SingleEvent("Conflict", start2, end2, "", "", true);
    event2.setAutoDecline(true);

    try {
      calendar.addEvent(event2, true);
      fail("Expected an exception due to conflict");
    } catch (Exception e) {
      String expectedMessage = "Event 'Conflict' conflicts with existing event 'Meeting'.";
      assertEquals(expectedMessage, e.getMessage());
    }
  }


  /**
   * Test that getAllEvents returns a non-empty list after adding an event.
   */
  @Test
  public void testGetAllEvents() throws InvalidDateException, EventConflictException {
    LocalDateTime start1 = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end1 = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event1 = new SingleEvent("Meeting", start1, end1, "", "", true);
    calendar.addEvent(event1, false);
    assertFalse("getAllEvents should not return an empty list after adding an event.",
        calendar.getAllEvents().isEmpty());
  }

  /**
   * Test that recurring events generate occurrences on the correct dates.
   */
  @Test
  public void testGetEventsOnForRecurringEvent()
      throws InvalidDateException, EventConflictException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 3, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 3, 9, 15);
    Set<DayOfWeek> recurrenceDays = new HashSet<>();
    recurrenceDays.add(DayOfWeek.MONDAY);
    RecurringEvent recurring = new RecurringEvent("Standup", start, end, "Daily meeting", "Room101",
        true, recurrenceDays, 2, null);
    calendar.addEvent(recurring, false);

    LocalDate date = LocalDate.of(2025, 3, 3);
    List<Event> eventsOnDate = calendar.getEventsOn(date);
    assertFalse("There should be recurring event occurrences on the given date.",
        eventsOnDate.isEmpty());
    boolean found = eventsOnDate.stream().anyMatch(e -> e.getSubject().equals("Standup"));
    assertTrue("The recurring event 'Standup' should be found on the given date.", found);
  }

  @Test
  public void addEvent() throws InvalidDateException, EventConflictException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Workshop", start, end, "Details", "RoomA", true);
    calendar.addEvent(event, false);
    assertTrue("Event should be added to the calendar.", calendar.getAllEvents().contains(event));
  }

  @Test
  public void getEventsOn() throws InvalidDateException, EventConflictException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 5, 14, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 5, 15, 0);
    SingleEvent event = new SingleEvent("Seminar", start, end, "Lecture", "Auditorium", true);
    calendar.addEvent(event, false);
    LocalDate date = LocalDate.of(2025, 3, 5);
    List<Event> eventsOnDate = calendar.getEventsOn(date);
    assertTrue("The event should be found on the given date.", eventsOnDate.contains(event));
  }

  @Test
  public void getAllEvents() throws InvalidDateException, EventConflictException {

    assertTrue("Calendar should be empty initially.", calendar.getAllEvents().isEmpty());
    LocalDateTime start = LocalDateTime.of(2025, 3, 7, 10, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 7, 11, 0);
    SingleEvent event = new SingleEvent("Lecture", start, end, "Math", "RoomB", true);
    calendar.addEvent(event, false);
    List<Event> allEvents = calendar.getAllEvents();
    assertEquals("There should be exactly one event in the calendar.", 1, allEvents.size());
    assertTrue("The added event should be present in the list.", allEvents.contains(event));
  }

  @Test
  public void isBusyAt() throws InvalidDateException, EventConflictException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 10, 13, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 10, 14, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "Team meeting", "Office", true);
    calendar.addEvent(event, false);

    LocalDateTime queryTime = LocalDateTime.of(2025, 3, 10, 13, 30);
    assertTrue("Calendar should be busy during the event.", calendar.isBusyAt(queryTime));

    LocalDateTime beforeTime = LocalDateTime.of(2025, 3, 10, 12, 0);
    assertFalse("Calendar should not be busy before the event.", calendar.isBusyAt(beforeTime));

    LocalDateTime afterTime = LocalDateTime.of(2025, 3, 10, 14, 30);
    assertFalse("Calendar should not be busy after the event.", calendar.isBusyAt(afterTime));
  }
}
--- End of file: model\CalendarModelTest.java ---


--- Start of file: model\CalendarServiceTest.java ---

package model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import org.junit.Test;

/**
 * Unit tests for CalendarService. These tests ensure event creation, editing, export, printing, and
 * conflict detection are functioning correctly.
 */

public class CalendarServiceTest {

  @Test
  public void testAddSingleEventAndGetAll() throws InvalidDateException, EventConflictException {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("Meeting",
        LocalDateTime.of(2025, 3, 27, 10, 0),
        LocalDateTime.of(2025, 3, 27, 11, 0),
        "Team meeting", "Room A", true, true);
    List<Event> events = service.getAllEvents();
    assertEquals(1, events.size());
    assertEquals("Meeting", events.get(0).getSubject());
  }

  @Test
  public void testAddRecurringEventAndOccurrences()
      throws InvalidDateException, EventConflictException {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    java.util.Set<java.time.DayOfWeek> days = new java.util.HashSet<>();
    days.add(java.time.DayOfWeek.MONDAY);
    service.addRecurringEvent("Workshop",
        LocalDateTime.of(2025, 4, 7, 9, 0),
        LocalDateTime.of(2025, 4, 7, 10, 0),
        "Weekly workshop", "Lab", true, days, 3,
        LocalDate.of(2025, 4, 21), true);
    List<Event> events = service.getAllEvents();
    List<Event> occs = events.get(0).getOccurrences();
    assertEquals(3, occs.size());
  }

  @Test
  public void testGetEventsOn() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("Breakfast",
        LocalDateTime.of(2025, 3, 27, 8, 0),
        LocalDateTime.of(2025, 3, 27, 9, 0),
        "Morning meal", "Cafe", true, true);
    List<Event> events = service.getEventsOn(LocalDate.of(2025, 3, 27));
    assertEquals(1, events.size());
  }

  @Test
  public void testIsBusyAt() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("Lunch",
        LocalDateTime.of(2025, 3, 27, 12, 0),
        LocalDateTime.of(2025, 3, 27, 13, 0),
        "Team lunch", "Cafeteria", true, true);
    assertTrue(service.isBusyAt(LocalDateTime.of(2025, 3, 27,
        12, 30)));
    assertFalse(service.isBusyAt(LocalDateTime.of(2025, 3, 27,
        14, 0)));
  }

  @Test
  public void testEditEvent() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("Seminar",
        LocalDateTime.of(2025, 3, 27, 15, 0),
        LocalDateTime.of(2025, 3, 27, 16, 0),
        "Tech Seminar", "Auditorium", true, true);
    service.editEvent("Seminar", LocalDateTime.of(2025, 3, 27,
            15, 0), "subject", "Updated Seminar",
        ICalendarService.EditMode.SINGLE);
    List<Event> events = service.getAllEvents();
    assertEquals("Updated Seminar", events.get(0).getSubject());
  }

  @Test
  public void testExporttoCSV() throws IOException, InvalidDateException, EventConflictException {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("Dinner",
        LocalDateTime.of(2025, 3, 27, 19, 0),
        LocalDateTime.of(2025, 3, 27, 20, 0),
        "Family dinner", "Home", true, true);
    String filePath = service.exportTo("csv", "test_export.csv");
    assertNotNull(filePath);
    File file = new File(filePath);
    assertTrue(file.exists());
    file.delete();
  }

  @Test
  public void testPrintEventsOn() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("Meeting",
        LocalDateTime.of(2025, 3, 27, 10, 0),
        LocalDateTime.of(2025, 3, 27, 11, 0),
        "Discussion", "Room X", true, true);
    String output = service.printEventsOn(LocalDate.of(2025, 3, 27));
    assertTrue(output.contains("Meeting"));
  }

  @Test
  public void testPrintEventsRange() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("Conference",
        LocalDateTime.of(2025, 3, 28, 9, 0),
        LocalDateTime.of(2025, 3, 28, 17, 0),
        "Annual conference", "Convention Center",
        true, true);
    String output = service.printEventsRange(LocalDateTime.of(2025, 3,
        28, 8, 0), LocalDateTime.of(2025, 3,
        28, 18, 0));
    assertTrue(output.contains("Conference"));
  }

  @Test(expected = EventConflictException.class)
  public void testAddEventConflict() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("ConflictTest",
        LocalDateTime.of(2025, 3, 27, 9, 0),
        LocalDateTime.of(2025, 3, 27, 10, 0),
        "Desc", "Room", true, true);
    service.addSingleEvent("ConflictTest",
        LocalDateTime.of(2025, 3, 27, 9, 30),
        LocalDateTime.of(2025, 3, 27, 10, 30),
        "Desc", "Room", true, true);
  }

  @Test
  public void testBusyAtEdge() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("EdgeTest", LocalDateTime.of(2025, 3,
            27, 14, 0),
        LocalDateTime.of(2025, 3, 27, 15, 0),
        "Desc", "Room", true, true);
    assertFalse(service.isBusyAt(LocalDateTime.of(2025, 3, 27,
        15, 0)));
    assertTrue(service.isBusyAt(LocalDateTime.of(2025, 3, 27,
        14, 59)));
  }

  @Test(expected = InvalidDateException.class)
  public void testAddEventInvalidDates() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("Event",
        LocalDateTime.of(2025, 3, 27, 12, 0),
        LocalDateTime.of(2025, 3, 27, 11, 0),
        "desc", "room", true, true);
  }
}


--- End of file: model\CalendarServiceTest.java ---


--- Start of file: model\CSVExporterTest.java ---

package model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

/**
 * Unit tests for CSVExporter. These tests verify the behavior of the exporter under many
 * scenarios.
 */
public class CSVExporterTest {

  private final String testFile = "test_calendar.csv";
  private ICalendarModel calendar;

  @Before
  public void setUp() throws InvalidDateException, EventConflictException {
    calendar = new CalendarModel();
  }

  @After
  public void tearDown() {
    File file = new File(testFile);
    if (file.exists()) {
      file.delete();
    }
  }

  @Test
  public void testExportCSVWithSingleEvent()
      throws IOException, InvalidDateException, EventConflictException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "desc", "Room 101", true);
    calendar.addEvent(event, false);

    CSVExporter exporter = new CSVExporter();
    String filePath = exporter.export(calendar, testFile);
    File csvFile = new File(filePath);
    assertTrue("CSV file should exist.", csvFile.exists());

    BufferedReader reader = new BufferedReader(new FileReader(csvFile));
    String header = reader.readLine();

    assertEquals(
        "Subject,Start Date,Start Time,End Date,End Time,AllDayEvent,Description,Location,Private",
        header);
    String dataRow = reader.readLine();
    assertNotNull("There should be a data row for the event.", dataRow);
    String[] parts = dataRow.split(",");
    assertEquals("Meeting", parts[0]);
    assertEquals(start.toLocalDate().toString(), parts[1]);
    assertEquals(start.toLocalTime().toString(), parts[2]);
    assertEquals(end.toLocalDate().toString(), parts[3]);
    assertEquals(end.toLocalTime().toString(), parts[4]);

    assertEquals("false", parts[5]);
    assertEquals("desc", parts[6]);
    assertEquals("Room 101", parts[7]);

    assertEquals("false", parts[8]);
    reader.close();
  }

  @Test
  public void testExportCSVWithRecurringEvent()
      throws IOException, InvalidDateException, EventConflictException {

    LocalDateTime start = LocalDateTime.of(2025, 3, 3, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 3, 9, 15);
    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.MONDAY);
    RecurringEvent recurring = new RecurringEvent("Standup", start, end, "", "", true, days, 2,
        null);
    calendar.addEvent(recurring, false);

    CSVExporter exporter = new CSVExporter();
    String filePath = exporter.export(calendar, testFile);
    File csvFile = new File(filePath);
    assertTrue("CSV file should exist.", csvFile.exists());

    BufferedReader reader = new BufferedReader(new FileReader(csvFile));
    String header = reader.readLine();
    assertEquals(
        "Subject,Start Date,Start Time,End Date,End Time,AllDayEvent,Description,Location,Private",
        header);
    String row1 = reader.readLine();
    String row2 = reader.readLine();
    assertNotNull("First occurrence row should not be null.", row1);
    assertNotNull("Second occurrence row should not be null.", row2);
    assertNull("There should be no more than two data rows.", reader.readLine());
    reader.close();
  }

  @Test
  public void testExportCSVWithEmptyCalendar() throws IOException {
    CSVExporter exporter = new CSVExporter();
    String filePath = exporter.export(calendar, testFile);
    File csvFile = new File(filePath);
    assertTrue("CSV file should exist.", csvFile.exists());

    BufferedReader reader = new BufferedReader(new FileReader(csvFile));
    String header = reader.readLine();
    assertEquals(
        "Subject,Start Date,Start Time,End Date,End Time,AllDayEvent,Description,Location,Private",
        header);
    String data = reader.readLine();
    assertNull("There should be no data rows when the calendar is empty.", data);
    reader.close();
  }

  @Test
  public void testReturnFilePath()
      throws IOException, InvalidDateException, EventConflictException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "", "", true);
    calendar.addEvent(event, false);

    CSVExporter exporter = new CSVExporter();
    String filePath = exporter.export(calendar, testFile);
    assertNotNull("File path returned should not be null.", filePath);
    assertTrue("File path should contain the test file name.", filePath.contains(testFile));
  }

}
--- End of file: model\CSVExporterTest.java ---


--- Start of file: model\CSVImporterTest.java ---

package model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.FileWriter;
import org.junit.Before;
import org.junit.Test;

/**
 * Unit tests for CSVImporter. These tests verify the behavior of the importer under many scenarios
 * including valid input, empty files, malformed rows, and mixed valid and invalid input.
 */
public class CSVImporterTest {

  ICalendarManager manager = new CalendarManager();
  IMultiCalendarService service = new MultiCalendarService(manager);

  @Before
  public void setUp() throws Exception {

    service.createCalendar("DUMMY", "UTC");
    service.useCalendar("DUMMY");
  }

  @Test
  public void importData() throws Exception {
    CSVImporter importer = new CSVImporter();
    File tempFile = File.createTempFile("validData", ".csv");
    FileWriter writer = new FileWriter(tempFile);
    writer.write(
        "Subject,Start Date,Start Time,End Date,End Time,AllDay,Description,Location,Private\n");
    writer.write("Meeting,2025-04-10,10:00,2025-04-10,11:00,false,Description,Office,false\n");
    writer.close();
    ICalendarModel model = manager.getCalendar("DUMMY").getCalendarModel();
    String result = importer.importData(model, tempFile.getAbsolutePath());
    assertEquals("Imported 1 events.", result);
  }

  @Test
  public void importEmptyFile() throws Exception {
    CSVImporter importer = new CSVImporter();
    File tempFile = File.createTempFile("emptyData", ".csv");
    FileWriter writer = new FileWriter(tempFile);
    writer.write("");
    writer.close();
    ICalendarModel model = manager.getCalendar("DUMMY").getCalendarModel();
    String result = importer.importData(model, tempFile.getAbsolutePath());
    assertEquals("Error: CSV file is empty.", result);
  }

  @Test
  public void importInvalidFieldCount() throws Exception {
    CSVImporter importer = new CSVImporter();
    File tempFile = File.createTempFile("invalidField", ".csv");
    FileWriter writer = new FileWriter(tempFile);
    writer.write(
        "Subject,Start Date,Start Time,End Date,End Time,AllDay,Description,Location,Private\n");
    writer.write("Meeting,2025-04-10,10:00\n");
    writer.close();
    ICalendarModel model = manager.getCalendar("DUMMY").getCalendarModel();
    String result = importer.importData(model, tempFile.getAbsolutePath());
    assertEquals("Imported 0 events.\n1 errors:\nLine 2: Invalid number of fields.\n", result);
  }

  @Test
  public void importInvalidDateFormat() throws Exception {
    CSVImporter importer = new CSVImporter();
    File tempFile = File.createTempFile("invalidDate", ".csv");
    FileWriter writer = new FileWriter(tempFile);
    writer.write(
        "Subject,Start Date,Start Time,End Date,End Time,AllDay,Description,Location,Private\n");
    writer.write("Meeting,invalid-date,10:00,2025-04-10,11:00,false,Description,Office,false\n");
    writer.close();
    ICalendarModel model = manager.getCalendar("DUMMY").getCalendarModel();
    String result = importer.importData(model, tempFile.getAbsolutePath());
    assertTrue(result.contains("could not be parsed"));
  }

  @Test
  public void importMixedData() throws Exception {
    CSVImporter importer = new CSVImporter();
    File tempFile = File.createTempFile("mixedData", ".csv");
    FileWriter writer = new FileWriter(tempFile);
    writer.write(
        "Subject,Start Date,Start Time,End Date,End Time,AllDay,Description,Location,Private\n");

    writer.write("Meeting,2025-04-10,10:00,2025-04-10,11:00,false,Description,Office,false\n");

    writer.write("Event,2025-04-11,12:00\n");
    writer.close();
    ICalendarModel model = manager.getCalendar("DUMMY").getCalendarModel();
    String result = importer.importData(model, tempFile.getAbsolutePath());
    assertEquals("Imported 1 events.\n1 errors:\nLine 3: Invalid number of fields.\n", result);
  }
}
--- End of file: model\CSVImporterTest.java ---


--- Start of file: model\EditEventOperationsTest.java ---

package model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import org.junit.Test;

/**
 * Unit tests for the EditEventOperations class. These tests cover editing both single and recurring
 * events using different modes like SINGLE, ALL, and FROM.
 */
public class EditEventOperationsTest {

  @Test
  public void testEditSingleEventSuccess() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("Meeting",
        LocalDateTime.of(2025, 5, 1, 10, 0),
        LocalDateTime.of(2025, 5, 1, 11, 0),
        "Desc", "Room", true, true);
    new EditEventOperations().editEvent(model, "Meeting",
        LocalDateTime.of(2025, 5, 1, 10, 0),
        "subject", "UpdatedMeeting", ICalendarService.EditMode.SINGLE);
    List<Event> events = model.getAllEvents();
    assertEquals("UpdatedMeeting", events.get(0).getSubject());
  }

  @Test(expected = UnsupportedOperationException.class)
  public void testEditSingleEventUnsupportedMode() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("Meeting",
        LocalDateTime.of(2025, 5, 1, 10, 0),
        LocalDateTime.of(2025, 5, 1, 11, 0),
        "Desc", "Room", true, true);
    new EditEventOperations().editEvent(model, "Meeting", LocalDateTime.of(2025,
            5, 1, 10, 0), "subject", "FailUpdate",
        ICalendarService.EditMode.ALL);
  }

  @Test
  public void testEditRecurringEventAllMode() throws Exception {
    CalendarModel model = new CalendarModel();
    RecurringEvent re = new RecurringEvent("Recurring",
        LocalDateTime.of(2025, 5, 2, 9, 0),
        LocalDateTime.of(2025, 5, 2, 10, 0),
        "Desc", "Room", true,
        Collections.singleton(DayOfWeek.FRIDAY),
        3, LocalDate.of(2025, 5, 16));
    re.setAutoDecline(true);
    model.addEvent(re, true);
    new EditEventOperations().editEvent(model, "Recurring", LocalDateTime.of(2025,
            5, 2, 9, 0), "location", "UpdatedRoom",
        ICalendarService.EditMode.ALL);
    List<Event> events = model.getAllEvents();
    RecurringEvent updated = (RecurringEvent) events.get(0);
    assertEquals("UpdatedRoom", updated.getLocation());
  }

  @Test(expected = Exception.class)
  public void testEditRecurringEventSingleModeNotFound() throws Exception {
    CalendarModel model = new CalendarModel();
    RecurringEvent reccuring = new RecurringEvent("Class",
        LocalDateTime.of(2025, 5, 8, 9, 0),
        LocalDateTime.of(2025, 5, 8, 10, 0),
        "Lecture", "Hall", true,
        Collections.singleton(DayOfWeek.THURSDAY),
        2, LocalDate.of(2025, 5, 15));
    reccuring.setAutoDecline(true);
    model.addEvent(reccuring, true);
    new EditEventOperations().editEvent(model, "Class", LocalDateTime.of(2025,
            5, 9, 9, 0), "subject", "NewClass",
        ICalendarService.EditMode.SINGLE);
  }

  @Test
  public void testEditRecurringEventFromMode() throws Exception {
    CalendarModel model = new CalendarModel();
    RecurringEvent re = new RecurringEvent("Seminar",
        LocalDateTime.of(2025, 5, 1, 14, 0),
        LocalDateTime.of(2025, 5, 1, 15, 0),
        "Talk", "Auditorium", true,
        Collections.singleton(DayOfWeek.FRIDAY),
        4, LocalDate.of(2025, 5, 29));
    re.setAutoDecline(true);
    model.addEvent(re, true);
    int beforeCount = model.getAllEvents().size();
    new EditEventOperations().editEvent(model, "Seminar", LocalDateTime.of(2025,
            5, 8, 14, 0), "description",
        "UpdatedTalk", ICalendarService.EditMode.FROM);
    int afterCount = model.getAllEvents().size();
    assertTrue(afterCount > beforeCount);
  }

  @Test(expected = UnsupportedOperationException.class)
  public void testEditEventInvalidProperty() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("Event",
        LocalDateTime.of(2025, 5, 1, 10, 0),
        LocalDateTime.of(2025, 5, 1, 11, 0),
        "Desc", "Room", true, true);
    new EditEventOperations().editEvent(model, "Event", LocalDateTime.of(2025,
            5, 1, 10, 0), "invalid", "value",
        ICalendarService.EditMode.SINGLE);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testUpdateEventStartTimeConflict() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("Conflict",
        LocalDateTime.of(2025, 5, 1, 10, 0),
        LocalDateTime.of(2025, 5, 1, 11, 0),
        "Desc", "Room", true, true);
    new EditEventOperations().editEvent(model, "Conflict", LocalDateTime.of(2025,
            5, 1, 10, 0), "start",
        "2025-05-01T11:30", ICalendarService.EditMode.SINGLE);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testUpdateEventEndTimeConflict() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);
    service.addSingleEvent("TestEnd",
        LocalDateTime.of(2025, 5, 1, 10, 0),
        LocalDateTime.of(2025, 5, 1, 11, 0),
        "Desc", "Room", true, true);
    new EditEventOperations().editEvent(model, "TestEnd", LocalDateTime.of(2025,
            5, 1, 10, 0), "end",
        "2025-05-01T09:30", ICalendarService.EditMode.SINGLE);
  }

  @Test
  public void testEditEventNoMatch() {
    try {
      CalendarModel model = new CalendarModel();
      CalendarService service = new CalendarService(model);
      service.addSingleEvent("NoMatch",
          LocalDateTime.of(2025, 5, 1, 10, 0),
          LocalDateTime.of(2025, 5, 1, 11, 0),
          "Desc", "Room", true, true);
      new EditEventOperations().editEvent(model, "NoMatch",
          LocalDateTime.of(2025, 5, 1, 12, 0),
          "subject", "New", ICalendarService.EditMode.SINGLE);
      fail("Expected exception for no matching event");
    } catch (Exception e) {
      assertTrue(e.getMessage().contains("No matching event"));
    }


  }

  @Test
  public void testEditSingleEventSetAutoDecline() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);

    service.addSingleEvent("TeamEvent",
        LocalDateTime.of(2025, 10, 1, 9, 0),
        LocalDateTime.of(2025, 10, 1, 10, 0),
        "Desc", "Room", true, false);

    new EditEventOperations().editEvent(model, "TeamEvent",
        LocalDateTime.of(2025, 10, 1, 9, 0),
        "autodecline", "anyValue",
        ICalendarService.EditMode.SINGLE);

    Event e = model.getAllEvents().get(0);
    assertTrue("Expected autoDecline to be set to true", e.isAutoDecline());
  }

  @Test
  public void testEditSingleEventSetPublicFlag() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);

    service.addSingleEvent("PublicEvent",
        LocalDateTime.of(2025, 9, 1, 9, 0),
        LocalDateTime.of(2025, 9, 1, 10, 0),
        "Desc", "Office", true, false);

    new EditEventOperations().editEvent(model, "PublicEvent",
        LocalDateTime.of(2025, 9, 1, 9, 0),
        "public", "false",
        ICalendarService.EditMode.SINGLE);

    Event e = model.getAllEvents().get(0);
    assertFalse("Expected event to become private", e.isPublic());
  }


  @Test
  public void testRecurringEventFromModeSplitCreated() throws Exception {
    CalendarModel model = new CalendarModel();
    CalendarService service = new CalendarService(model);

    service.addRecurringEvent("BiWeekly",
        LocalDateTime.of(2025, 6, 1, 14, 0),
        LocalDateTime.of(2025, 6, 1, 15, 0),
        "OldDesc", "Cafe", true,
        java.util.Collections.singleton(java.time.DayOfWeek.SUNDAY),
        4,
        java.time.LocalDate.of(2025, 6, 28),
        false);

    new EditEventOperations().editEvent(model, "BiWeekly",
        LocalDateTime.of(2025, 6, 8, 14, 0),
        "location", "UpdatedCafe",
        ICalendarService.EditMode.FROM);

    List<Event> all = model.getAllEvents();
    assertEquals("Expect 2 events after splitting (the old truncated + the new).", 2, all.size());

    Event second = all.get(1);
    assertEquals("Expected location in new recurring event to be UpdatedCafe", "UpdatedCafe",
        second.getLocation());
  }

  @Test
  public void testEditEventDescription() throws Exception {
    CalendarModel model = new CalendarModel();
    model.addEvent(new SingleEvent("Meeting",
        LocalDateTime.of(2025, 7, 1, 14, 0),
        LocalDateTime.of(2025, 7, 1, 15, 0),
        "OldDesc", "Room", true), true);

    new EditEventOperations().editEvent(model, "Meeting",
        LocalDateTime.of(2025, 7, 1, 14, 0),
        "description", "NewDesc",
        ICalendarService.EditMode.SINGLE);

    assertEquals("NewDesc", model.getAllEvents().get(0).getDescription());
  }

  @Test
  public void testEditStartWithoutAutoDecline() throws Exception {
    CalendarModel model = new CalendarModel();

    model.addEvent(new SingleEvent("Flexible",
        LocalDateTime.of(2025, 8, 1, 10, 0),
        LocalDateTime.of(2025, 8, 1, 11, 0),
        "", "Room", true), false);

    new EditEventOperations().editEvent(model, "Flexible",
        LocalDateTime.of(2025, 8, 1, 10, 0),
        "start", "2025-08-01T09:30",
        ICalendarService.EditMode.SINGLE);

    assertEquals(LocalDateTime.of(2025, 8, 1, 9, 30),
        model.getAllEvents().get(0).getStartDateTime());
  }


}

--- End of file: model\EditEventOperationsTest.java ---


--- Start of file: model\EventCopyHelperTest.java ---

package model;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.List;
import org.junit.Test;

/**
 * JUnit Test Cases for EventCopyHelper class.
 */
public class EventCopyHelperTest {

  @Test
  public void testCopySingleEvent() throws Exception {
    CalendarContext sourceContext = new
        CalendarContext("Source", "America/New_York");
    CalendarContext targetContext = new CalendarContext("Target", "Asia/Kolkata");
    sourceContext.getCalendarService().addSingleEvent("CopyTest",
        LocalDateTime.of(2025, 1, 1, 9, 0),
        LocalDateTime.of(2025, 1, 1, 10, 0),
        "Test description", "Office", true, true);
    LocalDateTime targetStart = LocalDateTime.of(2025, 1, 1, 19,
        30);
    String result = EventCopyHelper.copyEvent(sourceContext, targetContext, "CopyTest",
        LocalDateTime.of(2025, 1, 1, 9, 0), targetStart);
    assertTrue(result.contains("copied to calendar"));
    List<Event> targetEvents = targetContext.getCalendarService().getAllEvents();
    boolean found = false;
    for (Event e : targetEvents) {
      if (e.getSubject().equals("CopyTest") &&
          e.getStartDateTime().equals(targetStart)) {
        found = true;
        break;
      }
    }
    assertTrue(found);
  }

  @Test
  public void testCopyRecurringEventWithEndDate() throws Exception {

    CalendarContext sourceContext = new CalendarContext("SourceCal", "America/New_York");
    CalendarContext targetContext = new CalendarContext("TargetCal", "Europe/London");
    sourceContext.getCalendarService().addRecurringEvent(
        "RecEvent",
        LocalDateTime.of(2025, 3, 10, 9, 0),
        LocalDateTime.of(2025, 3, 10, 10, 0),
        "desc",
        "loc",
        true,
        java.util.Collections.singleton(java.time.DayOfWeek.MONDAY),
        4,
        LocalDate.of(2025, 3, 31),
        false
    );

    LocalDateTime sourceOccurrenceStart = LocalDateTime.of(2025, 3, 17, 9, 0);
    LocalDateTime targetStart = LocalDateTime.of(2025, 3, 17, 14, 0);

    String result = EventCopyHelper.copyRecurringEvent(
        sourceContext, targetContext, "RecEvent", sourceOccurrenceStart, targetStart);
    assertTrue(result.contains("copied to calendar 'TargetCal' starting at"));

    List<Event> targetEvents = targetContext.getCalendarService().getAllEvents();
    assertFalse("Expected at least one event in target calendar.", targetEvents.isEmpty());

    boolean foundRecCopy = false;
    for (Event e : targetEvents) {
      if (e.getSubject().equalsIgnoreCase("RecEvent")) {
        foundRecCopy = true;
        break;
      }
    }
    assertTrue("Copied recurring event should be found in target calendar.", foundRecCopy);
  }

  @Test
  public void testCopyRecurringEventNoEndDate() throws Exception {

    CalendarContext sourceContext = new CalendarContext("NoEndDateSrc", "America/Chicago");
    CalendarContext targetContext = new CalendarContext("NoEndDateTgt", "Asia/Tokyo");

    sourceContext.getCalendarService().addRecurringEvent(
        "NoEnd",
        LocalDateTime.of(2025, 4, 10, 9, 0),
        LocalDateTime.of(2025, 4, 10, 10, 0),
        "desc",
        "location",
        true,
        java.util.Collections.singleton(java.time.DayOfWeek.THURSDAY),
        2,
        null,
        false
    );

    LocalDateTime occurrenceStart = LocalDateTime.of(2025, 4, 10, 9, 0);
    LocalDateTime targetStart = LocalDateTime.of(2025, 4, 10, 20, 0);
    String msg = EventCopyHelper.copyRecurringEvent(
        sourceContext, targetContext, "NoEnd", occurrenceStart, targetStart);
    assertTrue(msg.contains("copied to calendar"));
  }

  @Test
  public void testCopyEventsOnDateNoEvents() throws Exception {

    CalendarContext sourceContext = new CalendarContext("Src", "America/New_York");
    CalendarContext targetContext = new CalendarContext("Tgt", "America/New_York");

    String dateResult = EventCopyHelper.copyEventsOnDate(
        sourceContext, targetContext, LocalDate.of(2025, 7, 1), LocalDate.of(2025, 7, 2));
    assertTrue(dateResult.contains("No events found on 2025-07-01"));
  }

  @Test
  public void testCopyEventsBetweenDatesEmptyResult() throws Exception {

    CalendarContext sourceContext = new CalendarContext("BtwSrc", "America/Denver");
    CalendarContext targetContext = new CalendarContext("BtwTgt", "America/Denver");

    sourceContext.getCalendarService().addSingleEvent(
        "OutsideRange",
        LocalDateTime.of(2025, 8, 15, 10, 0),
        LocalDateTime.of(2025, 8, 15, 11, 0),
        "desc", "office", true, true);

    String result = EventCopyHelper.copyEventsBetweenDates(
        sourceContext, targetContext,
        LocalDate.of(2025, 8, 1),
        LocalDate.of(2025, 8, 5),
        LocalDate.of(2025, 9, 1));
    assertTrue(result.contains("No events found between 2025-08-01 and 2025-08-05"));
  }

}


--- End of file: model\EventCopyHelperTest.java ---


--- Start of file: model\EventMigrationHelperTest.java ---

package model;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotEquals;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.List;
import org.junit.Test;

/**
 * Test cases for EventMigration class. Checks if the events migrated with the change in Zones.
 */
public class EventMigrationHelperTest {

  @Test
  public void testMigrateSingleEvent() throws Exception {
    CalendarContext context = new CalendarContext("TestCal", "America/New_York");
    context.getCalendarService().addSingleEvent("Meeting",
        LocalDateTime.of(2025, 1, 1, 9, 0),
        LocalDateTime.of(2025, 1, 1, 10, 0),
        "Discuss", "Room1", true, true);
    List<Event> before = context.getCalendarService().getAllEvents();
    assertFalse(before.isEmpty());
    LocalDateTime origStart = before.get(0).getStartDateTime();
    ZoneId zone = ZoneId.of("Asia/Kolkata");
    ZoneId oldZone = context.getTimezone();
    EventMigrationHelper.migrateEvents(context, oldZone, zone);
    List<Event> after = context.getCalendarService().getAllEvents();
    assertFalse(after.isEmpty());
    LocalDateTime newStart = after.get(0).getStartDateTime();
    assertNotEquals(origStart, newStart);
  }

  @Test
  public void testMigrateRecurringEvent() throws Exception {
    CalendarContext context = new CalendarContext("TestRec", "America/New_York");
    context.getCalendarService().addRecurringEvent("Recurring",
        LocalDateTime.of(2025, 1, 1, 9, 0),
        LocalDateTime.of(2025, 1, 1, 10, 0),
        "Weekly", "Office", true,
        java.util.Collections.singleton(java.time.DayOfWeek.WEDNESDAY),
        3, LocalDate.of(2025, 1, 15), true);
    List<Event> before = context.getCalendarService().getAllEvents();
    assertFalse(before.isEmpty());
    LocalDateTime origStart = before.get(0).getStartDateTime();

    ZoneId zone = ZoneId.of("Asia/Kolkata");
    ZoneId oldZone = context.getTimezone();
    EventMigrationHelper.migrateEvents(context, oldZone, zone);
    List<Event> after = context.getCalendarService().getAllEvents();
    assertFalse(after.isEmpty());
    LocalDateTime newStart = after.get(0).getStartDateTime();
    assertNotEquals(origStart, newStart);
  }
}



--- End of file: model\EventMigrationHelperTest.java ---


--- Start of file: model\EventPrinterTest.java ---

package model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.time.LocalDate;
import java.time.LocalDateTime;
import org.junit.Test;


/**
 * Unit tests for the EventPrinter class. These tests ensure event information is correctly printed
 * for given dates or ranges.
 */
public class EventPrinterTest {

  @Test
  public void testPrintEventsOnWithEvent() throws Exception {
    CalendarModel model = new CalendarModel();
    EventPrinter printer = new EventPrinter(model);
    SingleEvent event = new SingleEvent("TestEvent",
        LocalDateTime.of(2025, 5, 1, 9, 0),
        LocalDateTime.of(2025, 5, 1, 10, 0),
        "Description", "Room1", true);
    model.addEvent(event, false);
    String output = printer.printEventsOn(LocalDate.of(2025, 5, 1));
    assertTrue(output.contains("TestEvent"));
    assertTrue(output.contains("Room1"));
    assertTrue(output.contains("2025-05-01T09:00"));
  }

  @Test
  public void testPrintEventsRangeWithMultipleEvents() throws Exception {
    CalendarModel model = new CalendarModel();
    EventPrinter printer = new EventPrinter(model);
    SingleEvent event1 = new SingleEvent("Event1",
        LocalDateTime.of(2025, 5, 2, 8, 0),
        LocalDateTime.of(2025, 5, 2, 9, 0),
        "Desc", "Loc1", true);
    SingleEvent event2 = new SingleEvent("Event2",
        LocalDateTime.of(2025, 5, 2, 10, 0),
        LocalDateTime.of(2025, 5, 2, 11, 0),
        "Desc", "Loc2", true);
    model.addEvent(event1, false);
    model.addEvent(event2, false);
    String output = printer.printEventsRange(
        LocalDateTime.of(2025, 5, 2, 7, 0),
        LocalDateTime.of(2025, 5, 2, 12, 0));
    assertTrue(output.contains("Event1"));
    assertTrue(output.contains("Event2"));
    assertTrue(output.contains("2025-05-02T08:00"));
    assertTrue(output.contains("2025-05-02T10:00"));
  }

  @Test
  public void testPrintEventsOnEventWithNoLocation() throws Exception {
    CalendarModel model = new CalendarModel();
    EventPrinter printer = new EventPrinter(model);
    SingleEvent event = new SingleEvent("NoLocationEvent",
        LocalDateTime.of(2025, 5, 3, 14, 0),
        LocalDateTime.of(2025, 5, 3, 15, 0),
        "Desc", "", true);
    model.addEvent(event, false);
    String output = printer.printEventsOn(LocalDate.of(2025, 5, 3));
    assertTrue(output.contains("NoLocationEvent"));
    assertTrue(output.contains("2025-05-03T14:00"));
  }

  @Test
  public void testPrintEventsOnEmpty() throws Exception {
    CalendarModel model = new CalendarModel();
    EventPrinter printer = new EventPrinter(model);
    String output = printer.printEventsOn(LocalDate.of(2025, 5, 1));
    assertTrue(output.isEmpty());
    String[] lines = output.split("\n");
    assertEquals(1, lines.length);
  }
}

--- End of file: model\EventPrinterTest.java ---


--- Start of file: model\ExportFactoryTest.java ---

package model;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Unit Test cases for the {@link ExportFactoryTest} class, returns the appropriate Exporter based
 * on the format given. In the test if format is not supported yet, it verifies that.
 */
public class ExportFactoryTest {

  @Test(expected = Exception.class)
  public void getExport() {
    ExportFactory factory = new ExportFactory();
    Exporter exporter = factory.getExport("csv");
    assertNotNull(exporter);
    assertTrue(exporter instanceof CSVExporter);
    factory.getExport("json");

  }


}
--- End of file: model\ExportFactoryTest.java ---


--- Start of file: model\ImportFactoryTest.java ---

package model;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import org.junit.Test;

/**
 * Unit Test cases for the {@link ImportFactory} class, returns the appropriate Importer based on
 * the format given. In the test if format is not supported yet, it verifies that.
 */
public class ImportFactoryTest {

  @Test(expected = Exception.class)
  public void getImporter() {
    ImportFactory factory = new ImportFactory();
    Importer importer = factory.getImporter("csv");
    assertNotNull(importer);
    assertTrue(importer instanceof CSVImporter);

    factory.getImporter("json");
  }

}
--- End of file: model\ImportFactoryTest.java ---


--- Start of file: model\MultiCalendarServiceTest.java ---

package model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.junit.Before;
import org.junit.Test;

/**
 * JUnit Test Case for {@link MultiCalendarService} which is the factory of the Model.
 */
public class MultiCalendarServiceTest {

  private ICalendarManager manager;
  private IMultiCalendarService multiService;

  @Before
  public void setUp() throws Exception {
    manager = new CalendarManager();
    multiService = new MultiCalendarService(manager);
  }

  @Test
  public void testCreateCalendarSuccess() throws Exception {
    boolean created = multiService.createCalendar("Work",
        "America/New_York");
    assertTrue("Calendar should be created successfully", created);
  }

  @Test
  public void testCreateCalendarDuplicate() throws Exception {
    multiService.createCalendar("Personal", "America/Los_Angeles");
    boolean duplicateCreated = multiService.createCalendar("Personal",
        "America/Los_Angeles");
    assertFalse(duplicateCreated);
  }

  @Test
  public void testUseCalendar() throws Exception {
    multiService.createCalendar("Team", "Europe/London");
    boolean used = multiService.useCalendar("Team");
    assertTrue("Using an existing calendar should succeed", used);
  }

  @Test
  public void testDuplicateCalendar() throws Exception {
    multiService.createCalendar("OldName", "America/New_York");
    boolean edited = multiService.editCalendar("OldName", "name",
        "NewName");
    assertTrue(edited);
    multiService.createCalendar("Duplicate", "America/New_York");
    boolean duplicateEdit = multiService.editCalendar("NewName", "name",
        "Duplicate");
    assertFalse(duplicateEdit);
  }

  @Test
  public void testCreateCalendarActuallyAddsToManager() throws Exception {
    boolean result = multiService.createCalendar("TestCal", "Europe/Paris");
    assertTrue(result);

    assertNotNull(manager.getCalendar("TestCal"));
  }

  @Test
  public void testEditCalendarNameRemovesOldCalendar() throws Exception {
    multiService.createCalendar("Original", "UTC");
    multiService.editCalendar("Original", "name", "Renamed");

    assertNull(manager.getCalendar("Original"));
    assertNotNull(manager.getCalendar("Renamed"));
  }

  @Test
  public void testEditCalendarTimezoneMigratesEvents() throws Exception {

    multiService.createCalendar("TimezoneTest", "America/New_York");
    multiService.useCalendar("TimezoneTest");
    multiService.addSingleEvent("Meeting",
        LocalDateTime.of(2023, 1, 1, 9, 0),
        LocalDateTime.of(2023, 1, 1, 10, 0),
        "", "", true, true);

    boolean result = multiService.editCalendar("TimezoneTest", "timezone", "Europe/London");
    assertTrue(result);

    List<Event> events = manager.getCalendar("TimezoneTest").getCalendarService().getAllEvents();
    assertEquals(LocalDateTime.of(2023, 1, 1, 14, 0), events.get(0).getStartDateTime());
  }


  @Test
  public void testAddSingleEventActuallyCreatesEvent() throws Exception {
    multiService.createCalendar("EventTest", "UTC");
    multiService.useCalendar("EventTest");
    multiService.addSingleEvent("TestEvent",
        LocalDateTime.now(),
        LocalDateTime.now().plusHours(1),
        "", "", true, true);

    assertEquals(1, multiService.getAllEvents().size());
  }

  @Test
  public void testGetEventsOnEmptyCalendar() {
    assertNull(multiService.getEventsOn(LocalDate.now()));
  }

  @Test
  public void testGetAllEventsEmptyCalendar() {
    assertNull(multiService.getAllEvents());
  }

  @Test
  public void testIsBusyAtWithConflictingEvent() throws Exception {
    multiService.createCalendar("BusyTest", "UTC");
    multiService.useCalendar("BusyTest");
    LocalDateTime testTime = LocalDateTime.of(2023, 1, 1, 9, 30);
    multiService.addSingleEvent("Conflict",
        LocalDateTime.of(2023, 1, 1, 9, 0),
        LocalDateTime.of(2023, 1, 1, 10, 0),
        "", "", true, true);

    assertTrue(multiService.isBusyAt(testTime));
  }

  @Test
  public void testNewCalendarCreation() throws Exception {

    ICalendarManager calendarManager = new CalendarManager();
    MultiCalendarService service = new MultiCalendarService(calendarManager);

    String expectedName = "Test Calendar";
    String expectedTimezone = "America/New_York";

    boolean created = service.createCalendar(expectedName, expectedTimezone);
    assertTrue("The calendar should be created successfully", created);

    ICalendarContext calendar = calendarManager.getCalendar(expectedName);
    assertNotNull(calendar);
    assertEquals(expectedName, calendar.getName());
    assertEquals(ZoneId.of(expectedTimezone), calendar.getTimezone());
  }

  @Test
  public void testNewCalendarCreation2() throws Exception {
    ICalendarManager calendarManager = new CalendarManager();
    MultiCalendarService service = new MultiCalendarService(calendarManager);

    String expectedName = "Test Calendar";
    String expectedTimezone = "America/New_York";

    service.createCalendar(expectedName, expectedTimezone);
    service.useCalendar(expectedName);
    assertTrue(service.getCurrentCalendarNameAndZone()[0].equals(expectedName));
    assertTrue(service.getCurrentCalendarNameAndZone()[1].equals(expectedTimezone));
  }

  @Test(expected = Exception.class)
  public void invalidTimezone() throws Exception {
    ICalendarManager calendarManager = new CalendarManager();
    MultiCalendarService service = new MultiCalendarService(calendarManager);

    service.createCalendar("Test", "EIGN");
  }

  @Test
  public void testEditCalendarName() throws Exception {
    ICalendarManager calendarManager = new CalendarManager();
    MultiCalendarService service = new MultiCalendarService(calendarManager);

    service.createCalendar("Test", "America/New_York");
    service.useCalendar("Test");

    service.editCalendar("Test", "name", "Renamed");
    service.useCalendar("Renamed");

    service.editCalendar("Renamed", "timezone", "Europe/London");

    assertTrue(service.getCurrentCalendarNameAndZone()[0].equals("Renamed"));
    assertTrue(service.getCurrentCalendarNameAndZone()[1].equals("Europe/London"));


  }

  @Test
  public void testPrintEventsAfterTimezoneChange() throws Exception {
    ICalendarManager calendarManager = new CalendarManager();
    MultiCalendarService service = new MultiCalendarService(calendarManager);
    String calendarName = "TestCalendar";
    String initialTimezone = "UTC";

    service.createCalendar(calendarName, initialTimezone);
    service.useCalendar(calendarName);

    LocalDateTime start = LocalDateTime.of(2025, 4, 10, 10, 0);
    LocalDateTime end = LocalDateTime.of(2025, 4, 10, 11, 0);
    service.addSingleEvent("Meeting", start, end, "Desc", "Loc", false, false);

    service.editCalendar(calendarName, "timezone", "America/New_York");

    String printedEvents = service.printEventsOn(LocalDate.of(2025, 4, 10));
    assertTrue(printedEvents.contains("06:00"));
  }

  @Test(expected = Exception.class)
  public void addConflictingSingleEvent() throws Exception {
    ICalendarManager calendarManager = new CalendarManager();
    MultiCalendarService service = new MultiCalendarService(calendarManager);

    service.createCalendar("ABC", "America/New_York");
    service.useCalendar("ABC");

    LocalDateTime start1 = LocalDateTime.of(2025, 4, 10, 10, 0);
    LocalDateTime end1 = LocalDateTime.of(2025, 4, 10, 11, 0);
    service.addSingleEvent("Meeting1", start1, end1, "First meeting", "Office", false, false);

    LocalDateTime start2 = LocalDateTime.of(2025, 4, 10, 10, 30);
    LocalDateTime end2 = LocalDateTime.of(2025, 4, 10, 11, 30);

    service.addSingleEvent("Meeting2", start2, end2, "Conflicting meeting", "Office", false,
        false);

  }

  @Test(expected = Exception.class)
  public void addRecurringEventWithConflict() throws Exception {
    ICalendarManager calendarManager = new CalendarManager();
    MultiCalendarService service = new MultiCalendarService(calendarManager);

    service.createCalendar("ABC", "America/New_York");
    service.useCalendar("ABC");

    LocalDateTime start = LocalDateTime.of(2025, 4, 10, 10, 0);
    LocalDateTime end = LocalDateTime.of(2025, 4, 10, 11, 0);
    service.addSingleEvent("SingleEvent", start, end, "Desc", "Loc", false, false);

    Set<DayOfWeek> recurrenceDays = new HashSet<>();
    recurrenceDays.add(DayOfWeek.THURSDAY);
    LocalDate recurringEndDate = LocalDate.of(2025, 5, 8);

    service.addRecurringEvent("RecurringEvent", start, end, "Recurring Desc", "Recurring Loc",
        false, recurrenceDays, 5, recurringEndDate, false);
  }

  @Test(expected = Exception.class)
  public void addRecurringEventWithConflict2() throws Exception {
    ICalendarManager calendarManager = new CalendarManager();
    MultiCalendarService service = new MultiCalendarService(calendarManager);

    service.createCalendar("ABC", "America/New_York");
    service.useCalendar("ABC");

    LocalDateTime start = LocalDateTime.of(2025, 4, 10, 10, 0);
    LocalDateTime end = LocalDateTime.of(2025, 4, 10, 11, 0);
    Set<DayOfWeek> recurrenceDays = new HashSet<>();
    recurrenceDays.add(DayOfWeek.THURSDAY);
    LocalDate recurringEndDate = LocalDate.of(2025, 5, 8);
    service.addRecurringEvent("RecurringEvent", start, end, "Recurring Desc", "Recurring Loc",
        false, recurrenceDays, 5, recurringEndDate, false);

    service.addRecurringEvent("Prada", start, end, "Recurring Desc", "Recurring Loc", false,
        recurrenceDays, 5, recurringEndDate, false);
  }

  @Test(expected = Exception.class)
  public void addRecurringEventWithConflict3() throws Exception {
    ICalendarManager calendarManager = new CalendarManager();
    MultiCalendarService service = new MultiCalendarService(calendarManager);

    service.createCalendar("ABC", "America/New_York");
    service.useCalendar("ABC");

    LocalDateTime start = LocalDateTime.of(2025, 4, 10, 10, 0);
    LocalDateTime end = LocalDateTime.of(2025, 4, 10, 11, 0);
    Set<DayOfWeek> recurrenceDays = new HashSet<>();
    recurrenceDays.add(DayOfWeek.THURSDAY);
    LocalDate recurringEndDate = LocalDate.of(2025, 5, 8);
    service.addRecurringEvent("RecurringEvent", start, end, "Recurring Desc", "Recurring Loc",
        false, recurrenceDays, 5, recurringEndDate, false);

    service.addRecurringEvent("Prada", LocalDateTime.parse("2025-04-17"), end, "Recurring Desc",
        "Recurring Loc", false, recurrenceDays, 5, recurringEndDate, false);
  }

  @Test
  public void testCopySingleEventWithSameTimezone() throws Exception {
    ICalendarManager calendarManager = new CalendarManager();
    MultiCalendarService service = new MultiCalendarService(calendarManager);

    service.createCalendar("Source", "America/New_York");
    service.useCalendar("Source");
    LocalDateTime sourceStart = LocalDateTime.of(2025, 4, 10, 10, 0);
    LocalDateTime sourceEnd = LocalDateTime.of(2025, 4, 10, 11, 0);
    service.addSingleEvent("Meeting", sourceStart, sourceEnd, "Desc", "Loc", false, false);

    service.createCalendar("Target", "America/New_York");
    LocalDateTime targetStart = LocalDateTime.of(2025, 4, 10, 12, 0);
    service.copyEvent("Meeting", sourceStart, "Target", targetStart);

    service.useCalendar("Target");
    List<Event> events = service.getEventsOn(targetStart.toLocalDate());

    boolean found = false;
    for (Event event : events) {
      if ("Meeting".equals(event.getSubject()) && targetStart.equals(event.getStartDateTime())) {
        found = true;
        break;
      }
    }
    assertTrue(found);
  }

  @Test
  public void testCopyEventsBetweenWithSameTimezone() throws Exception {
    ICalendarManager calendarManager = new CalendarManager();
    MultiCalendarService service = new MultiCalendarService(calendarManager);

    service.createCalendar("Source", "America/New_York");
    service.createCalendar("Target", "America/New_York");

    service.useCalendar("Source");
    LocalDateTime event1Start = LocalDateTime.of(2025, 4, 10, 10, 0);
    LocalDateTime event1End = LocalDateTime.of(2025, 4, 10, 11, 0);
    service.addSingleEvent("Event1", event1Start, event1End, "Desc1", "Loc1", false, false);

    LocalDateTime event2Start = LocalDateTime.of(2025, 4, 11, 12, 0);
    LocalDateTime event2End = LocalDateTime.of(2025, 4, 11, 13, 0);
    service.addSingleEvent("Event2", event2Start, event2End, "Desc2", "Loc2", false, false);

    LocalDate sourceStartDate = LocalDate.of(2025, 4, 10);
    LocalDate sourceEndDate = LocalDate.of(2025, 4, 11);
    LocalDate targetStartDate = LocalDate.of(2025, 5, 1);

    service.copyEventsBetween(sourceStartDate, sourceEndDate, "Target", targetStartDate);

    service.useCalendar("Target");
    List<Event> events = service.getAllEvents();
    assertEquals(2, events.size());

    boolean foundEvent1 = false;
    boolean foundEvent2 = false;
    for (Event event : events) {
      if ("Event1".equals(event.getSubject())) {
        foundEvent1 = true;
      }
      if ("Event2".equals(event.getSubject())) {
        foundEvent2 = true;
      }
    }
    assertTrue(foundEvent1);
    assertTrue(foundEvent2);
  }

  @Test
  public void testCopyEventsBetweenWithDifferentTimezones() throws Exception {
    ICalendarManager calendarManager = new CalendarManager();
    MultiCalendarService service = new MultiCalendarService(calendarManager);

    service.createCalendar("Source", "America/New_York");
    service.createCalendar("Target", "Asia/Kolkata");

    service.useCalendar("Source");
    LocalDateTime event1Start = LocalDateTime.of(2025, 4, 10, 10, 0);
    LocalDateTime event1End = LocalDateTime.of(2025, 4, 10, 11, 0);
    service.addSingleEvent("Event1", event1Start, event1End, "Desc1", "Loc1", false, false);

    LocalDateTime event2Start = LocalDateTime.of(2025, 4, 11, 12, 0);
    LocalDateTime event2End = LocalDateTime.of(2025, 4, 11, 13, 0);
    service.addSingleEvent("Event2", event2Start, event2End, "Desc2", "Loc2", false, false);

    LocalDate sourceStartDate = LocalDate.of(2025, 4, 10);
    LocalDate sourceEndDate = LocalDate.of(2025, 4, 11);
    LocalDate targetStartDate = LocalDate.of(2025, 5, 1);

    service.copyEventsBetween(sourceStartDate, sourceEndDate, "Target", targetStartDate);

    service.useCalendar("Target");
    List<Event> events = service.getAllEvents();
    assertEquals(2, events.size());

    boolean foundEvent1 = false;
    boolean foundEvent2 = false;
    for (Event event : events) {
      if ("Event1".equals(event.getSubject())) {
        foundEvent1 = true;
      }
      if ("Event2".equals(event.getSubject())) {
        foundEvent2 = true;
      }
    }
    assertTrue(foundEvent1);
    assertTrue(foundEvent2);

  }


  @Test
  public void testIsBusyAtWhenEmpty() {
    assertFalse(multiService.isBusyAt(LocalDateTime.now()));
  }

  @Test
  public void testUseCalendarNonexistent() throws Exception {
    assertFalse(multiService.useCalendar("NonExistentCalendar"));
  }

  @Test
  public void testEditCalendarInvalidProperty() throws Exception {
    multiService.createCalendar("Cal1", "UTC");
    assertFalse(multiService.editCalendar("Cal1", "invalidProp", "someValue"));
  }

  @Test(expected = Exception.class)
  public void testCopyEventNonExistentTargetCalendar() throws Exception {
    multiService.createCalendar("SourceCal", "UTC");
    multiService.useCalendar("SourceCal");

    LocalDateTime sourceStart = LocalDateTime.of(2025, 4, 10, 10, 0);
    multiService.addSingleEvent("Event1", sourceStart, sourceStart.plusHours(1),
        "Description", "Location", true, false);
    multiService.copyEvent("Event1", sourceStart, "TargetCal",
        LocalDateTime.of(2025, 4, 10, 12, 0));
  }

  @Test
  public void testGetEventsOnAndGetAllEventsWhenNoActiveCalendar() {

    ICalendarManager emptyManager = new CalendarManager();
    IMultiCalendarService serviceWithoutActive = new MultiCalendarService(emptyManager);
    assertNull(serviceWithoutActive.getEventsOn(LocalDate.now()));
    assertNull(serviceWithoutActive.getAllEvents());
  }

  @Test
  public void testIsBusyAtWhenNoActiveCalendar() {
    ICalendarManager emptyManager = new CalendarManager();
    IMultiCalendarService serviceWithoutActive = new MultiCalendarService(emptyManager);
    assertFalse(serviceWithoutActive.isBusyAt(LocalDateTime.now()));
  }

  @Test(expected = Exception.class)
  public void testCopyEventsOnNonExistentTargetCalendar() throws Exception {
    multiService.createCalendar("Source", "UTC");
    multiService.useCalendar("Source");
    multiService.copyEventsOn(LocalDate.now(), "NonExistentTarget", LocalDate.now());
  }

}

--- End of file: model\MultiCalendarServiceTest.java ---


--- Start of file: model\RecurringEventTest.java ---

package model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import org.junit.Test;

/**
 * JUnit Test Case for {@link RecurringEvent}.
 */
public class RecurringEventTest {

  @Test
  public void testGenerateOccurrencesFixedCount() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 3, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 3, 9, 15);
    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.MONDAY);

    RecurringEvent re = new RecurringEvent("Standup", start, end, "", "", true, days, 3, null);
    List<SingleEvent> occurrences = re.generateOccurrences();
    assertEquals("There should be 3 occurrences.", 3, occurrences.size());
    for (SingleEvent occurrence : occurrences) {
      assertEquals("Occurrence should be on Monday.", DayOfWeek.MONDAY,
          occurrence.getStartDateTime().getDayOfWeek());
    }
  }

  @Test
  public void testGenerateOccurrencesUntilDate() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 3, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 3, 9, 15);
    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.MONDAY);

    LocalDate until = LocalDate.of(2025, 3, 17);
    RecurringEvent re = new RecurringEvent("WeeklyMeeting", start, end, "", "", true, days, -1,
        until);
    List<SingleEvent> occurrences = re.generateOccurrences();

    assertEquals("Expected 3 occurrences using recurrence end date.", 3, occurrences.size());
  }

  @Test(expected = InvalidDateException.class)
  public void testInvalidRecurringEventDifferentDay() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 3, 9, 0);

    LocalDateTime end = LocalDateTime.of(2025, 3, 4, 9, 15);
    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.MONDAY);
    new RecurringEvent("Invalid", start, end, "", "", true, days, 3, null);
  }

  @Test
  public void testRecurringEventConflict() throws InvalidDateException {
    LocalDateTime startRecurring = LocalDateTime.of(2025, 3, 3, 9, 0);
    LocalDateTime endRecurring = LocalDateTime.of(2025, 3, 3, 9, 15);
    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.MONDAY);
    RecurringEvent recurring = new RecurringEvent("Standup", startRecurring, endRecurring, "", "",
        true, days, 3, null);

    LocalDateTime startSingle = LocalDateTime.of(2025, 3, 3, 9, 5);
    LocalDateTime endSingle = LocalDateTime.of(2025, 3, 3, 9, 10);
    try {
      SingleEvent single = new SingleEvent("Overlap", startSingle, endSingle, "", "", true);
      assertTrue("Recurring event should conflict with overlapping single event.",
          recurring.conflictsWith(single));
    } catch (InvalidDateException e) {
      fail("No exception expected: " + e.getMessage());
    }
  }

  @Test
  public void testConflictsWithNoConflict() throws InvalidDateException {
    LocalDateTime startRecurring = LocalDateTime.of(2025, 3, 3, 9, 0);
    LocalDateTime endRecurring = LocalDateTime.of(2025, 3, 3, 9, 15);
    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.MONDAY);
    RecurringEvent recurring = new RecurringEvent("Standup", startRecurring, endRecurring,
        "Daily meeting", "Room1", true, days, 2, null);

    LocalDateTime singleStart = LocalDateTime.of(2025, 3, 3, 10, 0);
    LocalDateTime singleEnd = LocalDateTime.of(2025, 3, 3, 10, 30);
    try {
      SingleEvent single = new SingleEvent("OtherEvent", singleStart, singleEnd, "", "", true);
      assertFalse("There should be no conflict between non-overlapping events.",
          recurring.conflictsWith(single));
    } catch (InvalidDateException e) {
      fail("No exception expected: " + e.getMessage());
    }
  }

  @Test
  public void testGetOccurrencesReturnsExpectedList() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 3, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 3, 9, 15);
    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.MONDAY);
    RecurringEvent recurring = new RecurringEvent("Standup", start, end, "Daily meeting", "Room1",
        true, days, 3, null);
    List<Event> occs = recurring.getOccurrences();
    assertNotNull("Occurrences list should not be null.", occs);
    assertEquals("Expected 3 occurrences from getOccurrences.", 3, occs.size());
  }

  @Test
  public void testGenerateOccurrencesWithRecurrenceEndDate() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 3, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 3, 9, 15);
    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.MONDAY);
    LocalDate recurrenceEndDate = LocalDate.of(2025, 3, 10);
    RecurringEvent recurring = new RecurringEvent("Standup", start, end, "Daily meeting", "Room1",
        true, days, -1, recurrenceEndDate);
    List<SingleEvent> occurrences = recurring.generateOccurrences();

    assertEquals("Expected 2 occurrences based on recurrence end date.", 2, occurrences.size());
    assertEquals("The second occurrence should occur on the recurrence end date.",
        recurrenceEndDate, occurrences.get(1).getStartDateTime().toLocalDate());
  }


  @Test
  public void getRecurrenceDays() throws InvalidDateException {

    Set<DayOfWeek> expectedDays = new HashSet<>();
    expectedDays.add(DayOfWeek.MONDAY);
    expectedDays.add(DayOfWeek.WEDNESDAY);
    LocalDateTime start = LocalDateTime.of(2025, 3, 3, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 3, 9, 15);
    RecurringEvent recurring = new RecurringEvent("Standup", start, end, "Meeting", "Room1", true,
        expectedDays, 2, null);

    assertEquals("Recurrence days should match the provided set.", expectedDays,
        recurring.getRecurrenceDays());
  }

  @Test
  public void getOccurrenceCount() throws InvalidDateException {
    int occCount = 5;
    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.FRIDAY);
    LocalDateTime start = LocalDateTime.of(2025, 4, 4, 10, 0);
    LocalDateTime end = LocalDateTime.of(2025, 4, 4, 11, 0);
    RecurringEvent recurring = new RecurringEvent("Friday Meeting", start, end, "Discussion",
        "RoomF", true, days, occCount, null);

    assertEquals("Occurrence count should match the provided value.", occCount,
        recurring.getOccurrenceCount());
  }

  @Test
  public void getRecurrenceEndDate() throws InvalidDateException {
    LocalDate expectedEndDate = LocalDate.of(2025, 5, 1);
    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.TUESDAY);
    LocalDateTime start = LocalDateTime.of(2025, 4, 1, 14, 0);
    LocalDateTime end = LocalDateTime.of(2025, 4, 1, 15, 0);
    RecurringEvent recurring = new RecurringEvent("Tuesday Sync", start, end, "Sync meeting",
        "RoomT", true, days, -1, expectedEndDate);

    assertEquals("Recurrence end date should match the provided date.", expectedEndDate,
        recurring.getRecurrenceEndDate());
  }

  @Test
  public void setRecurrenceEndDate() throws InvalidDateException {
    LocalDate initialEnd = LocalDate.of(2025, 5, 1);
    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.THURSDAY);
    LocalDateTime start = LocalDateTime.of(2025, 4, 2, 16, 0);
    LocalDateTime end = LocalDateTime.of(2025, 4, 2, 17, 0);
    RecurringEvent recurring = new RecurringEvent("Thursday Check", start, end, "Check meeting",
        "RoomTh", true, days, 4, initialEnd);

    assertEquals("Initial recurrence end date should match.", initialEnd,
        recurring.getRecurrenceEndDate());

    LocalDate newEnd = LocalDate.of(2025, 5, 15);
    recurring.setRecurrenceEndDate(newEnd);
    assertEquals("Recurrence end date should be updated to the new value.", newEnd,
        recurring.getRecurrenceEndDate());
  }

}
--- End of file: model\RecurringEventTest.java ---


--- Start of file: model\SingleEventTest.java ---

package model;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;
import org.junit.Test;


/**
 * JUnit Test Case for {@link SingleEvent}.
 */
public class SingleEventTest {

  @Test
  public void testValidSingleEvent() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Meeting", start, end, "Desc", "Room 101", true);
    assertEquals("Meeting", event.getSubject());
    assertEquals(start, event.getStartDateTime());
    assertEquals(end, event.getEffectiveEndDateTime());
  }

  @Test(expected = InvalidDateException.class)
  public void testInvalidSingleEventEndBeforeStart() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 10, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 9, 0);
    new SingleEvent("Invalid", start, end, "", "", true);
  }

  @Test
  public void testAllDayEventEffectiveEndTime() throws InvalidDateException {
    LocalDateTime start = LocalDate.of(2025, 3, 1).atStartOfDay();
    SingleEvent event = new SingleEvent("AllDay", start, null, "", "", true);
    LocalDateTime expectedEnd = LocalDate.of(2025, 3, 1).atTime(23, 59);
    assertEquals(expectedEnd, event.getEffectiveEndDateTime());
  }

  @Test
  public void testConflictsBetweenSingleEvents() throws InvalidDateException {
    LocalDateTime start1 = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end1 = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event1 = new SingleEvent("Event1", start1, end1, "", "", true);

    LocalDateTime start2 = LocalDateTime.of(2025, 3, 1, 9, 30);
    LocalDateTime end2 = LocalDateTime.of(2025, 3, 1, 10, 30);
    SingleEvent event2 = new SingleEvent("Event2", start2, end2, "", "", true);

    assertTrue(event1.conflictsWith(event2));
    assertTrue(event2.conflictsWith(event1));
  }

  @Test
  public void testNonConflictingSingleEvents() throws InvalidDateException {
    LocalDateTime start1 = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end1 = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event1 = new SingleEvent("Event1", start1, end1, "", "", true);

    LocalDateTime start2 = LocalDateTime.of(2025, 3, 1, 10, 0);
    LocalDateTime end2 = LocalDateTime.of(2025, 3, 1, 11, 0);
    SingleEvent event2 = new SingleEvent("Event2", start2, end2, "", "", true);

    assertFalse(event1.conflictsWith(event2));
    assertFalse(event2.conflictsWith(event1));
  }

  @Test
  public void testConflictWithRecurringEventUsingSingleEvent() throws InvalidDateException {
    LocalDateTime singleStart = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime singleEnd = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent single = new SingleEvent("Test", singleStart, singleEnd, "", "", true);

    LocalDateTime recurStart = LocalDateTime.of(2025, 3, 1, 9, 30);
    LocalDateTime recurEnd = LocalDateTime.of(2025, 3, 1, 9, 45);
    Set<DayOfWeek> days = new HashSet<>();
    days.add(recurStart.getDayOfWeek());
    RecurringEvent recurring = new RecurringEvent("TestRecurring", recurStart, recurEnd, "", "",
        true, days, 1, null);

    assertTrue(single.conflictsWith(recurring));
  }

  @Test
  public void testGetOccurrencesReturnsSelf() throws InvalidDateException {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    SingleEvent event = new SingleEvent("Test", start, end, "Desc", "Room101", true);
    assertEquals(1, event.getOccurrences().size());
    assertSame(event, event.getOccurrences().get(0));
  }

}
--- End of file: model\SingleEventTest.java ---


--- Start of file: controller\CalendarControllerFactoryTest.java ---

package controller;

import static org.junit.Assert.assertTrue;

import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;
import view.ICalendarView;

/**
 * Tests the CalendarControllerFactory to ensure it returns the correct controller type based on the
 * provided arguments.
 */
public class CalendarControllerFactoryTest {

  @Test
  public void createController() throws Exception {
    CalendarControllerFactory factory = new CalendarControllerFactory();
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    ICalendarView view = new ICalendarView() {
      @Override
      public void start() {
        // View is needed by CalendarFactory.
        // Cannot use CalendarGUI here(pitest doesn't work if I do).
      }

      @Override
      public void setController(IGUIController controller) throws Exception {
        // Interface necessitates to use this methods.
      }
    };

    IAppController controller = factory.createController(null, service, view);
    assertTrue(controller instanceof GUIController);

    controller = factory.createController(new String[0], service, view);
    assertTrue(controller instanceof GUIController);

    controller = factory.createController(new String[]{"--mode", "interactive"}, service, view);
    assertTrue(controller instanceof TextBasedController);

    controller = factory.createController(new String[]{"--mode", "headless"}, service, view);
    assertTrue(controller instanceof TextBasedController);

    controller = factory.createController(new String[]{"--mode", "unknown"}, service, view);
    assertTrue(controller instanceof GUIController);

    controller = factory.createController(new String[]{"other"}, service, view);
    assertTrue(controller instanceof GUIController);
  }

}
--- End of file: controller\CalendarControllerFactoryTest.java ---


--- Start of file: controller\CommandParserStaticTest.java ---

package controller;

import static org.junit.Assert.assertEquals;

import java.time.LocalDateTime;
import model.InvalidDateException;
import org.junit.Test;

/**
 * Unit test for the static date-time parsing method in CommandParserStatic.
 */
public class CommandParserStaticTest {

  @Test
  public void testParseDateTimeStatic() throws InvalidDateException {
    String input = "2025-03-01T09:00";
    LocalDateTime dateTime = CommandParserStatic.parseDateTimeStatic(input);
    assertEquals(2025, dateTime.getYear());
    assertEquals(3, dateTime.getMonthValue());
    assertEquals(1, dateTime.getDayOfMonth());
    assertEquals(9, dateTime.getHour());
    assertEquals(0, dateTime.getMinute());
  }

}
--- End of file: controller\CommandParserStaticTest.java ---


--- Start of file: controller\CopyEventCommandParserTest.java ---

package controller;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;


/**
 * Unit tests for the CopyEventCommandParser class.
 */
public class CopyEventCommandParserTest {

  @Test
  public void testValidParse() {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    CopyEventCommandParser parser = new CopyEventCommandParser(service);

    String[] input = {"copy", "event", "Meeting", "on", "2025-02-01T10:00", "--target",
        "Cal2", "to", "2025-02-10T15:00"};
    assertTrue(parser.parse(input) instanceof CopyEventCommand);
  }

  @Test
  public void testInvalidParseReturnsFallback() {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    CopyEventCommandParser parser = new CopyEventCommandParser(service);

    String[] badInput = {"not", "a", "copy", "command"};
    Object result = parser.parse(badInput);
    assertFalse(result instanceof CopyEventCommand);
  }

  @Test
  public void testInvalidTokenCount() throws Exception {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    CopyEventCommandParser parser = new CopyEventCommandParser(service);

    // Test with 8 tokens instead of required 9
    String[] input = {"copy", "event", "Meeting", "on", "2025-02-01T10:00", "--target", "Cal2",
        "to"};
    Command cmd = parser.parse(input);
    assertTrue("Should return format error",
        cmd.execute().contains("Invalid copy event command format"));
  }

  @Test
  public void testMissingEventKeyword() throws Exception {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    CopyEventCommandParser parser = new CopyEventCommandParser(service);

    // Missing "event" keyword
    String[] input = {"copy", "meeting", "Meeting", "on", "2025-02-01T10:00", "--target", "Cal2",
        "to", "2025-02-10T15:00"};
    Command cmd = parser.parse(input);
    assertTrue("Should detect missing event keyword",
        cmd.execute().contains("missing 'event' keyword"));
  }

  @Test
  public void testMissingOnKeyword() throws Exception {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    CopyEventCommandParser parser = new CopyEventCommandParser(service);

    // Missing "on" keyword
    String[] input = {"copy", "event", "Meeting", "at", "2025-02-01T10:00", "--target", "Cal2",
        "to", "2025-02-10T15:00"};
    Command cmd = parser.parse(input);
    assertTrue("Should detect missing 'on' keyword",
        cmd.execute().contains("missing 'on' keyword"));
  }

  @Test
  public void testMissingTargetOption() throws Exception {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    CopyEventCommandParser parser = new CopyEventCommandParser(service);

    // Missing --target option
    String[] input = {"copy", "event", "Meeting", "on", "2025-02-01T10:00", "--dest", "Cal2", "to",
        "2025-02-10T15:00"};
    Command cmd = parser.parse(input);
    assertTrue("Should detect missing --target",
        cmd.execute().contains("missing '--target' option"));
  }

  @Test
  public void testMissingToKeyword() throws Exception {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    CopyEventCommandParser parser = new CopyEventCommandParser(service);

    // Missing "to" keyword
    String[] input = {"copy", "event", "Meeting", "on", "2025-02-01T10:00", "--target", "Cal2",
        "at", "2025-02-10T15:00"};
    Command cmd = parser.parse(input);
    assertTrue("Should detect missing 'to' keyword",
        cmd.execute().contains("missing 'to' keyword"));
  }
}
--- End of file: controller\CopyEventCommandParserTest.java ---


--- Start of file: controller\CopyEventCommandTest.java ---

package controller;

import static org.junit.Assert.assertTrue;

import java.time.LocalDateTime;
import model.CalendarContext;
import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;


/**
 * Unit test for the CopyEventCommand class. Verifies that an event can be successfully copied from
 * one calendar to another.
 */
public class CopyEventCommandTest {

  @Test
  public void testExecuteCopiesEvent() throws Exception {
    CalendarContext source = new CalendarContext("Source", "America/New_York");
    CalendarContext target = new CalendarContext("Target", "Asia/Kolkata");

    CalendarManager manager = new CalendarManager();
    manager.addCalendar(source);
    manager.addCalendar(target);
    manager.setCurrentCalendar("Source");

    IMultiCalendarService service = new MultiCalendarService(manager);

    source.getCalendarService().addSingleEvent("Test",
        LocalDateTime.of(2025, 2, 1, 10, 0),
        LocalDateTime.of(2025, 2, 1, 11, 0),
        "desc", "place", true, true);

    CopyEventCommand cmd = new CopyEventCommand(service, "Test",
        LocalDateTime.of(2025, 2, 1, 10, 0),
        "Target",
        LocalDateTime.of(2025, 2, 1, 20, 30));

    String result = cmd.execute();
    assertTrue(result.toLowerCase().contains("copied"));
  }
}
--- End of file: controller\CopyEventCommandTest.java ---


--- Start of file: controller\CopyEventsBetweenCommandParserTest.java ---

package controller;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;

/**
 * Test cases for the CopyEventsBetweenCommandParser class.
 */
public class CopyEventsBetweenCommandParserTest {

  @Test
  public void testValidParse() {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    CopyEventsBetweenCommandParser parser = new CopyEventsBetweenCommandParser(service);
    String[] input = {"copy", "events", "between", "2025-03-01", "and", "2025-03-03",
        "--target", "TargetCal", "to", "2025-06-01"
    };
    Object cmd = parser.parse(input);
    assertTrue(cmd instanceof CopyEventsBetweenCommand);
  }

  @Test
  public void testInvalidParse() {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    CopyEventsBetweenCommandParser parser = new CopyEventsBetweenCommandParser(service);
    String[] badInput = {"copy", "bad", "input"};
    Object cmd = parser.parse(badInput);
    assertFalse(cmd instanceof CopyEventsBetweenCommand);
  }


  @Test
  public void testInvalidTokenCount() throws Exception {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    CopyEventsBetweenCommandParser parser = new CopyEventsBetweenCommandParser(service);

    // Test with 9 tokens instead of 10
    String[] input = {"copy", "events", "between", "2025-03-01", "and", "2025-03-03",
        "--target", "TargetCal", "to"};
    Command cmd = parser.parse(input);
    assertTrue("Should detect invalid format",
        cmd.execute().contains("Invalid copy events between command format"));
  }

  @Test
  public void testMissingEventsBetweenKeywords() throws Exception {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    CopyEventsBetweenCommandParser parser = new CopyEventsBetweenCommandParser(service);

    // Missing "between" keyword
    String[] input = {"copy", "events", "from", "2025-03-01", "and", "2025-03-03",
        "--target", "TargetCal", "to", "2025-06-01"};
    Command cmd = parser.parse(input);
    assertTrue("Should detect invalid syntax",
        cmd.execute().contains("Invalid copy events between command syntax"));
  }

  @Test
  public void testMissingAndKeyword() throws Exception {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    CopyEventsBetweenCommandParser parser = new CopyEventsBetweenCommandParser(service);

    // Missing "and" keyword
    String[] input = {"copy", "events", "between", "2025-03-01", "to", "2025-03-03",
        "--target", "TargetCal", "to", "2025-06-01"};
    Command cmd = parser.parse(input);
    assertTrue("Should detect missing 'and'",
        cmd.execute().contains("Missing 'and' in copy events between command"));
  }

  @Test
  public void testMissingTargetOption() throws Exception {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    CopyEventsBetweenCommandParser parser = new CopyEventsBetweenCommandParser(service);

    // Missing --target
    String[] input = {"copy", "events", "between", "2025-03-01", "and", "2025-03-03",
        "--dest", "TargetCal", "to", "2025-06-01"};
    Command cmd = parser.parse(input);
    assertTrue("Should detect missing --target",
        cmd.execute().contains("Missing '--target' in copy events between command"));
  }

  @Test
  public void testMissingToKeyword() throws Exception {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    CopyEventsBetweenCommandParser parser = new CopyEventsBetweenCommandParser(service);

    // Missing "to" keyword
    String[] input = {"copy", "events", "between", "2025-03-01", "and", "2025-03-03",
        "--target", "TargetCal", "at", "2025-06-01"};
    Command cmd = parser.parse(input);
    assertTrue("Should detect missing 'to'",
        cmd.execute().contains("Missing 'to' keyword in copy events between command"));
  }

  @Test
  public void testInvalidDateFormat() throws Exception {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    CopyEventsBetweenCommandParser parser = new CopyEventsBetweenCommandParser(service);

    // Invalid date format
    String[] input = {"copy", "events", "between", "2025/03/01", "and", "2025-03-03",
        "--target", "TargetCal", "to", "2025-06-01"};
    Command cmd = parser.parse(input);
    assertTrue("Should handle date parse error",
        cmd.execute().contains("Error processing copy events between command"));
  }
}



--- End of file: controller\CopyEventsBetweenCommandParserTest.java ---


--- Start of file: controller\CopyEventsBetweenCommandTest.java ---

package controller;

import static org.junit.Assert.assertTrue;

import java.time.LocalDate;
import java.time.LocalDateTime;
import model.CalendarContext;
import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;

/**
 * Unit tests for the CopyEventsBetweenCommand class. These tests verify the behavior of copying
 * events between calendars over a date range.
 */
public class CopyEventsBetweenCommandTest {

  @Test
  public void testExecuteCopiesRange() throws Exception {
    CalendarContext sourceCal = new CalendarContext("SemesterSpring2025", "America/New_York");
    CalendarContext targetCal = new CalendarContext("SemesterFall2025", "Asia/Kolkata");

    sourceCal.getCalendarService().addSingleEvent("Orientation",
        LocalDateTime.of(2025, 3, 1, 9, 0),
        LocalDateTime.of(2025, 3, 1, 10, 0),
        "Intro session", "Auditorium", true, true);

    CalendarManager manager = new CalendarManager();
    manager.addCalendar(sourceCal);
    manager.addCalendar(targetCal);
    manager.setCurrentCalendar("SemesterSpring2025");

    IMultiCalendarService service = new MultiCalendarService(manager);

    CopyEventsBetweenCommand command = new CopyEventsBetweenCommand(service, LocalDate.of(2025,
        3, 1),
        LocalDate.of(2025, 3, 2), "SemesterFall2025",
        LocalDate.of(2025, 6, 1)
    );

    String result = command.execute();
    assertTrue(result.toLowerCase().contains("copied"));
  }

  @Test
  public void testExecuteNoEventsInRange() throws Exception {
    CalendarContext sourceCal = new CalendarContext("SourceCalendar",
        "America/New_York");
    CalendarContext targetCal = new CalendarContext("TargetCalendar",
        "Asia/Kolkata");

    sourceCal.getCalendarService().addSingleEvent("Workshop",
        LocalDateTime.of(2025, 2, 15, 14, 0),
        LocalDateTime.of(2025, 2, 15, 15, 0),
        "Topic", "Hall", true, true);

    CalendarManager manager = new CalendarManager();
    manager.addCalendar(sourceCal);
    manager.addCalendar(targetCal);
    manager.setCurrentCalendar("SourceCalendar");

    IMultiCalendarService service = new MultiCalendarService(manager);

    CopyEventsBetweenCommand command = new CopyEventsBetweenCommand(service,
        LocalDate.of(2025, 3, 1),
        LocalDate.of(2025, 3, 2),
        "TargetCalendar",
        LocalDate.of(2025, 4, 1)
    );
    String result = command.execute();
    assertTrue(result.toLowerCase().contains("no events"));
  }


  @Test
  public void testCopyBetweenSameCalendar() throws Exception {
    CalendarContext calendar = new CalendarContext("SameCal", "Asia/Kolkata");

    calendar.getCalendarService().addSingleEvent("SelfEvent",
        LocalDateTime.of(2025, 3, 10, 10, 0),
        LocalDateTime.of(2025, 3, 10, 11, 0),
        "Internal", "Room", true, true);

    CalendarManager manager = new CalendarManager();
    manager.addCalendar(calendar);
    manager.setCurrentCalendar("SameCal");

    IMultiCalendarService service = new MultiCalendarService(manager);

    CopyEventsBetweenCommand cmd = new CopyEventsBetweenCommand(service,
        LocalDate.of(2025, 3, 10),
        LocalDate.of(2025, 3, 10),
        "SameCal",
        LocalDate.of(2025, 4, 10));
    String result = cmd.execute();
    assertTrue(result.toLowerCase().contains("copied"));
  }
}

--- End of file: controller\CopyEventsBetweenCommandTest.java ---


--- Start of file: controller\CopyEventsOnCommandParserTest.java ---

package controller;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;

/**
 * Tests the CopyEventsOnCommandParser.
 */
public class CopyEventsOnCommandParserTest {

  @Test
  public void testValidParse() {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    CopyEventsOnCommandParser parser = new CopyEventsOnCommandParser(service);
    String[] input = {"copy", "events", "on", "2025-02-01", "--target", "CalX", "to", "2025-03-01"};
    Object cmd = parser.parse(input);
    assertTrue("Expected a CopyEventsOnCommand instance", cmd instanceof CopyEventsOnCommand);
  }

  @Test
  public void testInvalidParse() {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    CopyEventsOnCommandParser parser = new CopyEventsOnCommandParser(service);
    String[] badInput = {"copy", "invalid", "command"};
    Object cmd = parser.parse(badInput);
    assertFalse("Expected the parser not to produce a valid CopyEventsOnCommand",
        cmd instanceof CopyEventsOnCommand);
  }
}

--- End of file: controller\CopyEventsOnCommandParserTest.java ---


--- Start of file: controller\CopyEventsOnCommandTest.java ---

package controller;

import static org.junit.Assert.assertTrue;

import java.time.LocalDate;
import java.time.LocalDateTime;
import model.CalendarContext;
import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;

/**
 * JUnit Test Cases for UseCalendarCommandTest.
 */
public class CopyEventsOnCommandTest {

  @Test
  public void testCopyEventsOnDate() throws Exception {
    CalendarContext source = new CalendarContext("CourseCal", "America/New_York");
    CalendarContext target = new CalendarContext("BackupCal", "Asia/Kolkata");

    source.getCalendarService().addSingleEvent("Exam",
        LocalDateTime.of(2025, 4, 10, 9, 0),
        LocalDateTime.of(2025, 4, 10, 10, 0),
        "", "", true, true);

    CalendarManager m = new CalendarManager();
    m.addCalendar(source);
    m.addCalendar(target);
    m.setCurrentCalendar("CourseCal");
    IMultiCalendarService service = new MultiCalendarService(m);

    CopyEventsOnCommand cmd = new CopyEventsOnCommand(service, LocalDate.of(2025,
        4, 10), "BackupCal",
        LocalDate.of(2025, 6, 10)
    );

    assertTrue(cmd.execute().toLowerCase().contains("copied"));
  }


  @Test
  public void testCopyRecurringInstance() throws Exception {
    CalendarContext source = new CalendarContext("WeeklyCal", "America/New_York");
    CalendarContext target = new CalendarContext("RepeatTarget", "Asia/Kolkata");

    source.getCalendarService().addRecurringEvent("Yoga",
        LocalDateTime.of(2025, 5, 7, 7, 0),
        LocalDateTime.of(2025, 5, 7, 8, 0),
        "Morning", "Studio", true,
        java.util.Collections.singleton(java.time.DayOfWeek.WEDNESDAY),
        1, LocalDate.of(2025, 5, 21), true);

    CalendarManager m = new CalendarManager();
    m.addCalendar(source);
    m.addCalendar(target);
    m.setCurrentCalendar("WeeklyCal");
    IMultiCalendarService service = new MultiCalendarService(m);

    CopyEventsOnCommand command = new CopyEventsOnCommand(service,
        LocalDate.of(2025, 5, 7), "RepeatTarget",
        LocalDate.of(2025, 6, 7)
    );
    String result = command.execute();
    assertTrue(result.toLowerCase().contains("copied"));
  }
}


--- End of file: controller\CopyEventsOnCommandTest.java ---


--- Start of file: controller\CreateCalendarCommandParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import model.CalendarManager;
import model.MultiCalendarService;
import org.junit.Test;

/**
 * Tests for the CreateCalendarCommandParser class.
 */
public class CreateCalendarCommandParserTest {

  @Test
  public void testValidParse() {
    CreateCalendarCommandParser parser =
        new CreateCalendarCommandParser(new MultiCalendarService(new CalendarManager()));
    String[] input = {"create", "calendar", "--name", "Work", "--timezone", "Asia/Kolkata"};

    Object result = parser.parse(input);
    assertTrue(result instanceof CreateCalendarCommand);
  }

  @Test
  public void testMissingTimezoneFlagButHasValue() {
    CreateCalendarCommandParser parser =
        new CreateCalendarCommandParser(new MultiCalendarService(new CalendarManager()));
    String[] input = {"create", "calendar", "--name", "MyCal", "Asia/Kolkata"};

    Object result = parser.parse(input);
    assertFalse(result instanceof CreateCalendarCommand);
  }

  @Test
  public void testInvalidTokenLength() throws Exception {
    CreateCalendarCommandParser parser = new CreateCalendarCommandParser(
        new MultiCalendarService(new CalendarManager()));
    String[] shortInput = {"create", "calendar", "--name", "Work"};
    Command cmd = parser.parse(shortInput);
    assertEquals("Invalid create calendar command.", cmd.execute());
  }

  @Test
  public void testMissingTimezoneFlagReturnsSpecificError() throws Exception {
    CreateCalendarCommandParser parser = new CreateCalendarCommandParser(
        new MultiCalendarService(new CalendarManager()));
    String[] input = {"create", "calendar", "--name", "MyCal", "UTC"};
    Command cmd = parser.parse(input);
    assertEquals("Invalid create calendar command.", cmd.execute());
  }

  @Test
  public void testValidCommandReturnsNonNull() {
    CreateCalendarCommandParser parser = new CreateCalendarCommandParser(
        new MultiCalendarService(new CalendarManager()));
    String[] validInput = {"create", "calendar", "--name", "Home", "--timezone", "Europe/Paris"};
    Command cmd = parser.parse(validInput);
    assertNotNull(cmd);
  }


}


--- End of file: controller\CreateCalendarCommandParserTest.java ---


--- Start of file: controller\CreateCalendarCommandTest.java ---

package controller;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;

/**
 * Tests for the CreateCalendarCommand class.
 */
public class CreateCalendarCommandTest {

  @Test
  public void testCreateValidCalendar() throws Exception {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);

    CreateCalendarCommand cmd = new CreateCalendarCommand(service, "NewCal", "Asia/Kolkata");
    String result = cmd.execute();

    assertTrue(result.contains("created"));
    assertNotNull(manager.getCalendar("NewCal"));
  }

  @Test
  public void testDuplicateCalendarFails() throws Exception {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    service.createCalendar("NewCal", "Asia/Kolkata");

    CreateCalendarCommand cmd = new CreateCalendarCommand(service, "NewCal",
        "Asia/Kolkata");
    String result = cmd.execute();
    assertTrue(result.toLowerCase().contains("failed"));
  }
}


--- End of file: controller\CreateCalendarCommandTest.java ---


--- Start of file: controller\CreateCommandParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import model.CalendarModel;
import model.CalendarService;
import model.ICalendarModel;
import model.ICalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * JUnit Test Cases for CreateCommandParserTest.
 */

public class CreateCommandParserTest {

  private CreateCommandParser parser;

  /**
   * Sets up the test fixture before each test.
   */
  @Before
  public void setUp() {

    ICalendarModel calendarModel = new CalendarModel();
    ICalendarService calendarService = new CalendarService(calendarModel);
    parser = new CreateCommandParser(calendarService);
  }


  @Test
  public void testMissingEventKeyword() throws Exception {
    String[] tokens = ("create evnt Meeting from "
        + "2025-03-01T09:00 to 2025-03-01T10:00").split("\\s+");
    Command cmd = parser.parse(tokens);
    String result = cmd.execute();
    assertTrue(result.startsWith("Invalid create command"));
  }

  /**
   * Test 2: Single event with autoDecline flag in a normal time-bound event.
   */
  @Test
  public void testAutoDeclineSingleEvent() {
    String[] tokens = ("create event --autoDecline "
        + "Meeting from 2025-03-01T09:00 to 2025-03-01T10:00").split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    try {
      String result = cmd.execute();
      assertEquals("Event created: Meeting", result);
    } catch (Exception e) {
      fail("No exception expected: " + e.getMessage());
    }
  }

  /**
   * Test 3: Single event without autoDecline flag in a normal time-bound event.
   */
  @Test
  public void testNoAutoDeclineSingleEvent() {
    String[] tokens = ("create event Meeting from "
        + "2025-03-01T09:00 to 2025-03-01T10:00").split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    try {
      String result = cmd.execute();
      assertEquals("Event created: Meeting", result);
    } catch (Exception e) {
      fail("No exception expected: " + e.getMessage());
    }
  }


  @Test
  public void testTimeBoundMissingTo() throws Exception {
    String[] tokens = "create event Meeting from 2025-03-01T09:00 2025-03-01T10:00".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertEquals("Expected 'to' after start time.", result);
  }

  @Test
  public void testTimeBoundRecurringMissingTimesKeyword() throws Exception {
    String[] tokens = ("create event Meeting "
        + "from 2025-03-01T09:00 to 2025-03-01T10:00 repeats MTWRF for 3").split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertEquals("Expected 'times' after occurrence count.", result);
  }

  /**
   * Test 6: Time-bound recurring event with "repeats" and "until" keyword.
   */
  @Test
  public void testTimeBoundRecurringUntil() {
    String[] tokens = ("create event Meeting "
        + "from 2025-03-01T09:00 to 2025-03-01T10:00 repeats MTWRF until 2025-03-15").split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    try {
      String result = cmd.execute();
      assertEquals("Recurring event created: Meeting", result);
    } catch (Exception e) {
      fail("No exception expected: " + e.getMessage());
    }
  }

  /**
   * Test 7: All-day event using the "on" branch with only a date.
   */
  @Test
  public void testAllDayEventWithDate() {
    String[] tokens = "create event Meeting on 2025-03-02".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    try {
      String result = cmd.execute();
      assertEquals("Event created: Meeting", result);
    } catch (Exception e) {
      fail("No exception expected: " + e.getMessage());
    }
  }

  /**
   * Test 8: All-day event using the "on" branch with a date-time.
   */
  @Test
  public void testAllDayEventWithDateTime() {
    String[] tokens = "create event Meeting on 2025-03-02T00:00".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    try {
      String result = cmd.execute();
      assertEquals("Event created: Meeting", result);
    } catch (Exception e) {
      fail("No exception expected: " + e.getMessage());
    }
  }


  @Test
  public void testAllDayRecurringMissingTimesKeyword() throws Exception {
    String[] tokens = "create event Meeting on 2025-03-02 repeats MTWRF for 3".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertEquals("Expected 'times' after occurrence count.", result);
  }

  /**
   * Test 10: All-day recurring event with "repeats" and "until" keyword.
   */
  @Test
  public void testAllDayRecurringUntil() {
    String[] tokens = ("create event Meeting on "
        + "2025-03-02 repeats MTWRF until 2025-03-10").split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    try {
      String result = cmd.execute();
      assertEquals("Recurring event created: Meeting", result);
    } catch (Exception e) {
      fail("No exception expected: " + e.getMessage());
    }
  }


  @Test
  public void testInvalidCreateCommandFormat() throws Exception {
    String[] tokens = "create event Meeting in 2025-03-01T09:00".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertEquals("Invalid create command format.", result);
  }


  @Test
  public void testCatchBlockInvalidDate() throws Exception {
    String[] tokens = "create event Meeting from invalidDate to 2025-03-01T10:00".split("\\s+");
    Command cmd = parser.parse(tokens);
    String result = cmd.execute();
    assertTrue(result.startsWith("Error processing create command:"));
  }

  @Test
  public void testAllDayEventRepeatsInvalidDayString() throws Exception {
    String[] tokens = "create event Meeting on 2025-03-02 repeats X for 2 times".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);

    String result = cmd.execute();
    assertEquals("Error processing create command: Invalid weekday character: X", result);

  }
}
--- End of file: controller\CreateCommandParserTest.java ---


--- Start of file: controller\CreateEventCommandTest.java ---

package controller;

import static org.junit.Assert.assertEquals;

import java.time.LocalDateTime;
import model.CalendarModel;
import model.CalendarService;
import model.ICalendarService;
import model.InvalidDateException;
import org.junit.Before;
import org.junit.Test;

/**
 * Tests for the CreateEventCommand class.
 */
public class CreateEventCommandTest {

  private CalendarModel calendar;
  private ICalendarService calendarService;

  /**
   * Sets up the test fixture before each test.
   */
  @Before
  public void setUp() {
    calendar = new CalendarModel();
    calendarService = new CalendarService(calendar);
  }


  @Test
  public void testExecuteCreateEvent() throws Exception {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    CreateEventCommand cmd = new CreateEventCommand(calendarService, false,
        "Meeting", start, end, "desc", "room", true);
    String result = cmd.execute();
    assertEquals("Event created: Meeting", result);
    assertEquals(1, calendar.getAllEvents().size());
  }


  @Test(expected = InvalidDateException.class)
  public void testCreateEventInvalidDate() throws Exception {
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 10, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 9, 0);
    new CreateEventCommand(calendarService, false, "Meeting", start, end, "", "", true).execute();
  }
}
--- End of file: controller\CreateEventCommandTest.java ---


--- Start of file: controller\CreateRecurringEventCommandTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import model.CalendarModel;
import model.CalendarService;
import model.ICalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * JUnit Test Cases for CreateRecurringEventCommandTest class.
 */

public class CreateRecurringEventCommandTest {

  private CalendarModel calendar;
  private CreateCommandParser parser;

  /**
   * Sets up the test fixture before each test.
   */
  @Before
  public void setUp() {
    calendar = new CalendarModel();
    ICalendarService calendarService = new CalendarService(calendar);
    parser = new CreateCommandParser(calendarService);
  }

  /**
   * Tests that a valid recurring event command is added to the calendar. The test verifies that the
   * returned message is correct and that the event is present in the calendar.
   */
  @Test
  public void testRecurringEventIsAddedToCalendar() {
    String commandLine = "create event --autoDecline Standup from "
        + "2025-03-01T09:00 to 2025-03-01T09:15 repeats MTWRF until 2025-03-15";
    Command cmd = parser.parse(commandLine.split("\\s+"));
    assertNotNull(cmd);

    try {
      String result = cmd.execute();

      assertEquals("Recurring event created: Standup", result);

      assertFalse(calendar.getAllEvents().isEmpty());

      boolean found = calendar.getAllEvents().stream()
          .anyMatch(e -> e.getSubject().equals("Standup"));
      assertTrue(found);
    } catch (Exception e) {
      fail("Unexpected exception: " + e.getMessage());
    }
  }

}
--- End of file: controller\CreateRecurringEventCommandTest.java ---


--- Start of file: controller\EditCalendarCommandParserTest.java ---

package controller;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;

/**
 * JUnit Test Case for {@link EditCalendarCommandParser}.
 */

public class EditCalendarCommandParserTest {

  @Test
  public void testValidParse() {
    EditCalendarCommandParser parser =
        new EditCalendarCommandParser(new MultiCalendarService(new CalendarManager()));
    String[] input = {"edit", "calendar", "--name", "OldName", "--property", "name", "NewName"};

    Command cmd = parser.parse(input);
    assertTrue(cmd instanceof EditCalendarCommand);
  }

  @Test
  public void testInvalidParse() {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    EditCalendarCommandParser parser = new EditCalendarCommandParser(service);
    String[] input = {"edit", "calendar", "OldCal"};
    Command result = parser.parse(input);
    assertFalse(result instanceof EditCalendarCommand);
  }

  @Test
  public void emptyParse() throws Exception {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    EditCalendarCommandParser parser = new EditCalendarCommandParser(service);
    String[] input = {};
    Command result = parser.parse(input);
    String r = result.execute();
    assertTrue(r.equals("Invalid edit calendar command."));

  }

}


--- End of file: controller\EditCalendarCommandParserTest.java ---


--- Start of file: controller\EditCalendarCommandTest.java ---

package controller;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import model.CalendarContext;
import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;

/**
 * JUnit Test Case for {@link EditCalendarCommand}.
 */

public class EditCalendarCommandTest {

  @Test
  public void testEditNameSuccess() throws Exception {
    CalendarManager manager = new CalendarManager();
    CalendarContext context = new CalendarContext("OldName", "Asia/Kolkata");
    manager.addCalendar(context);
    IMultiCalendarService service = new MultiCalendarService(manager);

    EditCalendarCommand cmd = new EditCalendarCommand(service, "OldName",
        "name", "NewName");
    String result = cmd.execute();

    assertTrue(result.toLowerCase().contains("updated"));
    assertNotNull(manager.getCalendar("NewName"));
  }

  @Test
  public void testInvalidProperty() throws Exception {
    CalendarManager manager = new CalendarManager();
    CalendarContext context = new CalendarContext("OldName", "Asia/Kolkata");
    manager.addCalendar(context);
    IMultiCalendarService service = new MultiCalendarService(manager);

    EditCalendarCommand cmd = new EditCalendarCommand(service, "OldName", "invalid", "val");
    String result = cmd.execute();

    assertTrue(result.toLowerCase().contains("unknown calendar property"));
  }
}


--- End of file: controller\EditCalendarCommandTest.java ---


--- Start of file: controller\EditCommandParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;
import model.CalendarModel;
import model.CalendarService;
import model.ICalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * JUnit Test Case for {@link EditCommandParser}.
 */

public class EditCommandParserTest {

  /**
   * Unit tests for the EditCommandParser class.
   */

  private EditCommandParser parser;

  /**
   * Sets up the test fixture before each test.
   */
  @Before
  public void setUp() {
    CalendarModel calendar = new CalendarModel();
    ICalendarService calendarService = new CalendarService(calendar);
    parser = new EditCommandParser(calendarService);
  }

  /**
   * Tests the SINGLE mode branch with a valid edit command.
   */
  @Test
  public void testEditEventSingleModeValid() {
    CalendarModel calendar = new CalendarModel();
    CalendarService service = new CalendarService(calendar);
    EditCommandParser parsera = new EditCommandParser(service);
    try {
      service.addSingleEvent("Meeting",
          LocalDateTime.of(2025, 3, 1, 9, 0),
          LocalDateTime.of(2025, 3, 1, 10, 0),
          "", "", true, false);
    } catch (Exception e) {
      fail(e.getMessage());
    }
    String[] tokens = ("edit event subject Meeting from 2025-03-01T09:00 to "
        + "2025-03-01T10:00 with TeamMeeting").split(
        "\\s+");
    Command cmd = parsera.parse(tokens);
    assertNotNull(cmd);
    try {
      String result = cmd.execute();
      assertTrue(result.contains("Edited event(s)"));
    } catch (Exception e) {
      fail(e.getMessage());
    }
  }

  /**
   * Tests that missing "from" in the edit event command returns the expected error message.
   */
  @Test
  public void testEditEventMissingFrom() throws Exception {
    String[] tokens = ("edit event subject Meeting 2025-03-01T09:00 to "
        + "2025-03-01T10:00 with TeamMeeting").split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull("Expected a command object even for invalid syntax", cmd);
    String result = cmd.execute();
    assertEquals("Expected 'from' in edit event command.", result);
  }

  /**
   * Tests the "edit events" branch in FROM mode.
   */
  @Test
  public void testEditEventsFromModeValid() throws Exception {
    CalendarModel calendar = new CalendarModel();
    CalendarService service = new CalendarService(calendar);
    EditCommandParser parsera = new EditCommandParser(service);

    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.SATURDAY);
    service.addRecurringEvent(
        "Meeting",
        LocalDateTime.of(2025, 3, 1, 9, 0),
        LocalDateTime.of(2025, 3, 1, 10, 0),
        "desc",
        "loc",
        true,
        days,
        -1,
        LocalDate.of(2025, 3, 22),
        false
    );

    String[] tokens = ("edit events location Meeting from 2025-03-08T09:00 with NewLocation"
    ).split("\\s+");
    Command cmd = parsera.parse(tokens);
    assertNotNull(cmd);

    String result = cmd.execute();
    assertTrue(result.contains("Edited event(s)"));
  }


  /**
   * Tests the "edit events" branch in ALL mode.
   */
  @Test
  public void testEditEventsAllModeValid() throws Exception {
    CalendarModel calendar = new CalendarModel();
    CalendarService service = new CalendarService(calendar);
    EditCommandParser parser = new EditCommandParser(service);

    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.SATURDAY);
    service.addRecurringEvent(
        "Meeting",
        LocalDateTime.of(2025, 3, 1, 9, 0),
        LocalDateTime.of(2025, 3, 1, 10, 0),
        "desc",
        "loc",
        true,
        days,
        3,
        null,
        false
    );

    String[] tokens = "edit events description Meeting with NewDescription".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);

    String result = cmd.execute();
    assertTrue(result.contains("Edited event(s)"));
  }

  /**
   * Tests missing "with" keyword returns the expected error message.
   */
  @Test
  public void testEditCommandMissingWith() throws Exception {
    String[] tokens = ("edit event subject Meeting from "
        + "2025-03-01T09:00 to 2025-03-01T10:00 TeamMeeting").split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull("Expected a command object even if 'with' is missing", cmd);
    String result = cmd.execute();
    assertEquals("Edit command missing 'with' and new value.", result);
  }

  /**
   * Tests an invalid date token in the edit command.
   */
  @Test
  public void testEditEventInvalidDate() throws Exception {
    String[] tokens = ("edit event subject Meeting from invalidDate "
        + "to 2025-03-01T10:00 with NewValue").split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull("Expected a command even with an invalid date", cmd);
    String result = cmd.execute();
    assertTrue(result.startsWith("Error processing edit command:"));
  }

  /**
   * Tests missing "with" keyword in SINGLE mode.
   */
  @Test
  public void testEditCommandMissingWith_SingleMode() throws Exception {
    String[] tokens = ("edit event subject Meeting from "
        + "2025-03-01T09:00 to 2025-03-01T10:00 TeamMeeting").split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull("Expected a command object even if 'with' is missing", cmd);
    String result = cmd.execute();
    assertEquals("Edit command missing 'with' and new value.", result);
  }

  /**
   * Tests missing "with" keyword in ALL mode.
   */
  @Test
  public void testEditCommandMissingWith_AllMode() throws Exception {
    String[] tokens = "edit events subject Meeting".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertEquals("Edit command missing 'with' and new value.", result);
  }

  /**
   * Tests an invalid edit command type (tokens[1] not "event" or "events").
   */
  @Test
  public void testInvalidEditCommandType() throws Exception {
    String[] tokens = "edit something".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertEquals("Invalid edit command.", result);
  }

  /**
   * Tests invalid token after edit command.
   */
  @Test
  public void testInvalidTokenAfterEdit() throws Exception {
    String[] tokens = "edit wrongCommand".split("\\s+");
    Command cmd = parser.parse(tokens);
    String result = cmd.execute();
    assertEquals("Invalid edit command.", result);
  }

  /**
   * Tests valid SINGLE mode command without auto-decline.
   */
  @Test
  public void testEditEventSingleModeNoAutoDecline() throws Exception {
    CalendarModel calendar = new CalendarModel();
    CalendarService service = new CalendarService(calendar);
    EditCommandParser parser = new EditCommandParser(service);

    service.addSingleEvent("Meeting",
        LocalDateTime.of(2025, 3, 1, 9, 0),
        LocalDateTime.of(2025, 3, 1, 10, 0),
        "", "", true, false);

    String[] tokens = ("edit event subject Meeting from 2025-03-01T09:00 to "
        + "2025-03-01T10:00 with TeamMeeting")
        .split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);

    String result = cmd.execute();
    assertTrue(result.contains("Edited event(s)"));
  }


  @Test
  public void testEditEventSingleModeWithAutoDecline() throws Exception {
    CalendarModel calendar = new CalendarModel();
    CalendarService service = new CalendarService(calendar);
    EditCommandParser parser = new EditCommandParser(service);

    service.addSingleEvent("Meeting",
        LocalDateTime.of(2025, 3, 1, 9, 0),
        LocalDateTime.of(2025, 3, 1, 10, 0),
        "", "", true, false);

    String[] tokens = ("edit event --autoDecline subject Meeting "
        + "from 2025-03-01T09:00 to 2025-03-01T10:00 with TeamMeeting").split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);

    String result = cmd.execute();
    assertTrue(result.contains("Edited event(s)"));
  }


  /**
   * Tests the "edit events" branch in ALL mode without auto-decline.
   */
  @Test
  public void testEditEventsAllModeNoAutoDecline() throws Exception {
    CalendarModel calendar = new CalendarModel();
    CalendarService service = new CalendarService(calendar);
    EditCommandParser parser = new EditCommandParser(service);

    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.SATURDAY);
    service.addRecurringEvent("Meeting",
        LocalDateTime.of(2025, 3, 1, 9, 0),
        LocalDateTime.of(2025, 3, 1, 10, 0),
        "", "",
        true,
        days,
        3,
        null,
        false);

    String[] tokens = "edit events subject Meeting with FinalMeeting".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);

    String result = cmd.execute();
    assertTrue(result.contains("Edited event(s)"));
  }


  @Test
  public void testEditCommandMissingFrom() throws Exception {
    String[] tokens = "edit event subject Meeting TeamMeeting".split("\\s+");
    Command cmd = parser.parse(tokens);
    String result = cmd.execute();
    assertEquals("Expected 'from' in edit event command.", result);
  }


  @Test
  public void testEditEventsAllModeWithAutoDecline() throws Exception {
    CalendarModel calendar = new CalendarModel();
    CalendarService service = new CalendarService(calendar);
    EditCommandParser parser = new EditCommandParser(service);

    Set<DayOfWeek> days = new HashSet<>();
    days.add(DayOfWeek.SATURDAY);

    service.addRecurringEvent(
        "Meeting",
        LocalDateTime.of(2025, 3, 1, 9, 0),
        LocalDateTime.of(2025, 3, 1, 10, 0),
        "desc",
        "loc",
        true,
        days,
        -1,
        LocalDate.of(2025, 3, 29),
        false
    );

    String[] tokens = "edit events --autoDecline description Meeting with NewDesc".split("\\s+");
    Command cmd = parser.parse(tokens);
    String result = cmd.execute();

    assertTrue(result.contains("Edited event(s)"));
  }


  /**
   * Tests the "edit events" branch (FROM mode) with an invalid date token. Expected syntax: "edit
   * events location Meeting from invalidDate with NewLocation"
   */
  @Test
  public void testEditEventsFromModeInvalidDate() throws Exception {
    String[] tokens = ("edit events location Meeting "
        + "from invalidDate with NewLocation").split("\\s+");
    Command cmd = parser.parse(tokens);
    String result = cmd.execute();
    assertTrue(result.startsWith("Error processing edit command:"));
  }

  @Test
  public void testEditCommandTooShort() throws Exception {
    String[] tokens = "edit event".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull("Command should be created even for too-short input", cmd);
    String result = cmd.execute();
    assertTrue(result.contains("Error processing edit command:"));
  }

  /**
   * Tests missing "with" keyword in the "events" branch.
   */
  @Test
  public void testEditEventsMissingWith() throws Exception {
    String[] tokens = "edit events subject Meeting".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull("Even if 'with' is missing, a command object is created", cmd);
    String result = cmd.execute();
    assertEquals("Edit command missing 'with' and new value.", result);
  }

  /**
   * Tests "edit events" branch in FROM mode with missing "with" or new value.
   */
  @Test
  public void testEditEventsFromNoWithOrValue() throws Exception {
    String[] tokens = "edit events subject Meeting from 2025-03-01T09:00".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertEquals("Edit command missing 'with' and new value.", result);
  }

  /**
   * Tests "edit events" branch in FROM mode with "with" keyword but no value.
   */
  @Test
  public void testEditEventsFromModeMissingValueAfterWith() throws Exception {
    String[] tokens = "edit events subject Meeting from 2025-03-01T09:00 with".split("\\s+");
    Command cmd = parser.parse(tokens);
    String result = cmd.execute();
    assertEquals("Edit command missing 'with' and new value.", result);
  }

  @Test
  public void testAutoDeclineAsLastToken() throws Exception {
    String[] tokens = "edit event --autoDecline".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertTrue(cmd.execute().contains("Error processing edit command"));
  }

  @Test
  public void testMissingDateTimeAfterFrom() throws Exception {
    String[] tokens = "edit event subject Meeting from".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertTrue(cmd.execute().contains("Error processing edit command"));
  }

  @Test
  public void testWithAtLastPosition() throws Exception {
    String[] tokens = "edit events subject Meeting with".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertEquals("Edit command missing 'with' and new value.", cmd.execute());
  }

  @Test
  public void testInvalidCommandAfterEditEvents() throws Exception {
    String[] tokens = "edit events invalid".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertTrue(cmd.execute().contains("Error processing edit command"));
  }

}
--- End of file: controller\EditCommandParserTest.java ---


--- Start of file: controller\EditEventCommandTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.time.LocalDateTime;
import model.CalendarModel;
import model.CalendarService;
import model.InvalidDateException;
import model.SingleEvent;
import org.junit.Before;
import org.junit.Test;

/**
 * JUnit Test Case for {@link EditEventCommand}.
 */

public class EditEventCommandTest {

  private CalendarModel calendar;
  private CalendarService service;

  @Before
  public void setUp() {
    calendar = new CalendarModel();
    service = new CalendarService(calendar);
  }

  @Test
  public void testEditSingleEvent() throws Exception {
    service.addSingleEvent("Meeting",
        LocalDateTime.of(2025, 3, 1, 9, 0),
        LocalDateTime.of(2025, 3, 1, 10, 0),
        "", "", true, false);
    LocalDateTime target = LocalDateTime.of(2025, 3, 1, 9, 0);
    EditEventCommand cmd = new EditEventCommand(service, "Meeting", target, "subject",
        "TeamMeeting", EditEventCommand.EditMode.SINGLE);
    String result = cmd.execute();
    assertTrue(result.contains("Edited event(s)"));
    assertEquals("TeamMeeting", calendar.getAllEvents().get(0).getSubject());
  }

  @Test(expected = Exception.class)
  public void testEditEventNotFound() throws Exception {
    LocalDateTime target = LocalDateTime.of(2025, 3, 1, 11, 0);
    EditEventCommand cmd = new EditEventCommand(service, "Meeting", target, "subject",
        "TeamMeeting", EditEventCommand.EditMode.SINGLE);
    String result = cmd.execute();
  }


  @Test
  public void testEditLocationForSingleEvent() throws Exception {
    service.addSingleEvent("Meeting",
        LocalDateTime.of(2025, 3, 1, 9, 0),
        LocalDateTime.of(2025, 3, 1, 10, 0),
        "", "", true, false);
    LocalDateTime target = LocalDateTime.of(2025, 3, 1, 9, 0);
    EditEventCommand cmd = new EditEventCommand(service, "Meeting", target, "location", "Room202",
        EditEventCommand.EditMode.SINGLE);
    String result = cmd.execute();
    assertTrue(result.contains("Edited event(s)"));
    assertEquals("Room202", calendar.getAllEvents().get(0).getLocation());
  }

  @Test
  public void testEditEndTimeForSingleEvent() throws Exception {
    service.addSingleEvent("Meeting",
        LocalDateTime.of(2025, 3, 1, 9, 0),
        LocalDateTime.of(2025, 3, 1, 10, 0),
        "", "", true, false);
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    EditEventCommand cmd = new EditEventCommand(service, "Meeting", start, "end",
        "2025-03-01T11:00", EditEventCommand.EditMode.SINGLE);
    String result = cmd.execute();
    assertTrue(result.contains("Edited event(s)"));
    SingleEvent updatedEvent = (SingleEvent) calendar.getAllEvents().get(0);
    assertEquals(LocalDateTime.of(2025, 3, 1, 11, 0), updatedEvent.getEffectiveEndDateTime());
  }

  @Test
  public void testEditStartTimeAfterEndTimeShouldFail() {
    try {
      service.addSingleEvent("Meeting",
          LocalDateTime.of(2025, 3, 1, 9, 0),
          LocalDateTime.of(2025, 3, 1, 10, 0),
          "", "", true, false);
    } catch (Exception e) {
      fail(e.getMessage());
    }
    LocalDateTime target = LocalDateTime.of(2025, 3, 1, 9, 0);
    EditEventCommand cmd = new EditEventCommand(service, "Meeting", target, "start",
        "2025-03-01T13:00", EditEventCommand.EditMode.SINGLE, false);
    try {
      cmd.execute();
      fail();
    } catch (IllegalArgumentException | InvalidDateException e) {
      assertEquals("Start time cannot be after end time.", e.getMessage());
    } catch (Exception e) {
      fail(e.getMessage());
    }
  }


  @Test
  public void testEditEndTimeBeforeStartTimeShouldFail() {
    try {
      service.addSingleEvent("Meeting",
          LocalDateTime.of(2025, 3, 1, 9, 0),
          LocalDateTime.of(2025, 3, 1, 10, 0),
          "", "", true, false);
    } catch (Exception e) {
      fail(e.getMessage());
    }
    LocalDateTime target = LocalDateTime.of(2025, 3, 1, 9, 0);
    EditEventCommand cmd = new EditEventCommand(service, "Meeting", target, "end",
        "2025-03-01T08:00", EditEventCommand.EditMode.SINGLE, false);
    try {
      cmd.execute();
      fail();
    } catch (IllegalArgumentException | InvalidDateException e) {
      assertEquals("End time cannot be before start time.", e.getMessage());
    } catch (Exception e) {
      fail(e.getMessage());
    }
  }

  @Test
  public void testEditTimeConflictPrevention() throws Exception {
    LocalDateTime startA = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime endA = LocalDateTime.of(2025, 3, 1, 10, 0);
    service.addSingleEvent("Meeting", startA, endA, "", "", true, false);
    LocalDateTime startB = LocalDateTime.of(2025, 3, 1, 11, 0);
    LocalDateTime endB = LocalDateTime.of(2025, 3, 1, 12, 0);
    service.addSingleEvent("Meeting", startB, endB, "", "", true, false);
    EditEventCommand cmd = new EditEventCommand(service, "Meeting", startB, "start",
        "2025-03-01T09:30", EditEventCommand.EditMode.SINGLE, true);
    try {
      cmd.execute();
    } catch (IllegalArgumentException e) {
      assertEquals("Edit would cause a conflict.", e.getMessage());
    }
  }

  @Test
  public void testEditPublicFlagForSingleEvent() throws Exception {
    service.addSingleEvent("Meeting",
        LocalDateTime.of(2025, 3, 1, 9, 0),
        LocalDateTime.of(2025, 3, 1, 10, 0),
        "", "", true, false);
    LocalDateTime target = LocalDateTime.of(2025, 3, 1, 9, 0);
    EditEventCommand cmd = new EditEventCommand(service, "Meeting", target, "public", "false",
        EditEventCommand.EditMode.SINGLE);
    String result = cmd.execute();
    assertTrue(result.contains("Edited event(s)"));
    boolean isPublic = calendar.getAllEvents().get(0).isPublic();
    assertFalse(isPublic);
  }
}






--- End of file: controller\EditEventCommandTest.java ---


--- Start of file: controller\ExportCalendarCommandTest.java ---

package controller;

import static org.junit.Assert.assertNotEquals;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.time.LocalDateTime;
import model.CalendarModel;
import model.CalendarService;
import model.ICalendarService;
import org.junit.Test;

/**
 * JUnit Test Case for {@link ExportCalendarCommandTest}. Verifies that the CSV are exported and its
 * feedback string is returned.
 */

public class ExportCalendarCommandTest {


  @Test
  public void testExportCalendarReturnMessage() throws Exception {
    CalendarModel calendara = new CalendarModel();
    ICalendarService calendar = new CalendarService(calendara);
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    calendar.addSingleEvent("Meeting", start, end, "desc", "room", true, false);

    String fileName = "test_export_message.csv";
    ExportCalendarCommand exportCmd = new ExportCalendarCommand(calendar, "csv", fileName);
    String result = exportCmd.execute();

    assertNotEquals("", result);
    assertTrue(result.startsWith("Calendar exported to:"));

    File exportedFile = new File(fileName);
    assertTrue(exportedFile.exists());
  }


  @Test
  public void testExportCalendarIOException() throws Exception {
    CalendarModel calendara = new CalendarModel();
    ICalendarService calendar = new CalendarService(calendara);
    String invalidFileName = "/nonexistent_folder/test_export.csv";
    ExportCalendarCommand exportCmd = new ExportCalendarCommand(calendar, "csv", invalidFileName);
    String result = exportCmd.execute();
    assertTrue(result.startsWith("Export failed:"));
  }
}
--- End of file: controller\ExportCalendarCommandTest.java ---


--- Start of file: controller\ExportCommandParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import model.CalendarModel;
import model.CalendarService;
import model.ICalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * JUnit Test Case for {@link ExportCommandParserTest}.
 */

public class ExportCommandParserTest {

  private ExportCommandParser parser;

  /**
   * Sets up the test fixture before each test.
   */
  @Before
  public void setUp() {
    CalendarModel calendara = new CalendarModel();
    ICalendarService calendar = new CalendarService(calendara);
    parser = new ExportCommandParser(calendar);
  }


  @Test
  public void testValidExportCommand() throws Exception {
    String[] tokens = "export cal test.csv".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertTrue(result.startsWith("Calendar exported to:"));
  }


  @Test
  public void testInvalidExportCommand() throws Exception {
    String[] tokens = "export cal".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertEquals("Invalid export command.", result);
  }


  @Test
  public void testExportParserException() throws Exception {
    String[] tokens = new String[]{"export", null, "test.csv"};
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertTrue(result.startsWith("Error processing export command:"));
  }


  @Test
  public void testValidExport2() throws Exception {
    String[] tokens = {"export", "cal", "test.csv"};
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertTrue(result.startsWith("Calendar exported to:"));
  }


  @Test
  public void testValidExport3() throws Exception {
    String[] tokens = {"export", "CAL", "test.csv", "extraToken"};
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertTrue(result.startsWith("Calendar exported to:"));
  }


  @Test
  public void testInvalidExportCommandWrongKeyword() throws Exception {
    String[] tokens = {"export", "file", "test.csv"};
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertEquals("Invalid export command.", result);
  }
}
--- End of file: controller\ExportCommandParserTest.java ---


--- Start of file: controller\ExtendedCalendarControllerTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;

/**
 * Tests for the {@link ExtendedCalendarControllerTest}.
 */

public class ExtendedCalendarControllerTest {

  @Test
  public void testExitCommand() {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    ExtendedCalendarController controller = new ExtendedCalendarController(service);
    String result = controller.processCommand("exit");
    assertEquals("exit", result);
  }

  @Test
  public void testUnknownCommand() {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    ExtendedCalendarController controller = new ExtendedCalendarController(service);
    String result = controller.processCommand("foobar");
    assertEquals("Unknown command.", result);
  }

  @Test
  public void testEmptyCommand() {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    ExtendedCalendarController controller = new ExtendedCalendarController(service);
    String result = controller.processCommand("");
    assertEquals("", result);
  }

  @Test
  public void testInvalidPrintCommand() {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    ExtendedCalendarController controller = new ExtendedCalendarController(service);
    String result = controller.processCommand("print events on not-a-date");
    assertTrue(result.toLowerCase().contains("invalid date format"));
  }
}

--- End of file: controller\ExtendedCalendarControllerTest.java ---


--- Start of file: controller\GUIControllerTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Before;
import org.junit.Test;
import view.ICalendarView;

/**
 * Tests for the {@link GUIController} class.
 */
public class GUIControllerTest {

  private GUIController controller;

  /**
   * Initializes the test controller and sets up a default calendar for use.
   */
  @Before
  public void setUp() throws Exception {
    ICalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    ICalendarView view = new ICalendarView() {
      @Override
      public void start() {
        // View is needed by CalendarFactory.
        // Cannot use CalendarGUI here(pitest doesn't work if I do).
      }

      @Override
      public void setController(IGUIController controller) throws Exception {
        // Interface necessitates to use this methods.
      }
    };
    controller = new GUIController(service, view);

    controller.createCalendar("Default", "UTC");
    controller.useCalendar("Default");
  }

  @Test
  public void useCalendar() throws Exception {

    String createResult = controller.createCalendar("TestCalendar", "UTC");
    assertEquals("Calendar created: TestCalendar", createResult);

    String result = controller.useCalendar("TestCalendar");
    assertEquals("Using calendar: TestCalendar", result);
  }

  @Test
  public void createCalendar() {

    String result = controller.createCalendar("MyCalendar", "Europe/London");
    assertEquals("Calendar created: MyCalendar", result);

    String duplicateResult = controller.createCalendar("MyCalendar", "Europe/London");
    assertEquals("Calendar creation failed: Duplicate calendar name.", duplicateResult);
  }

  @Test
  public void createSingleEvent() {

    String result = controller.createSingleEvent(
        "Meeting",
        "2025-04-10T10:00",
        "2025-04-10T11:00",
        "Team meeting",
        "Conference Room",
        true,
        false);
    assertEquals("Event created: Meeting", result);
  }

  @Test
  public void createRecurringEvent() {

    String result = controller.createRecurringEvent(
        "WeeklyMeeting",
        "2025-04-10T10:00",
        "2025-04-10T11:00",
        "Recurring team sync",
        "Board Room",
        true,
        "MWF",
        "3",
        "",
        false);
    assertEquals("Recurring event created: WeeklyMeeting", result);
  }

  @Test
  public void editEvent() {

    String createResult = controller.createSingleEvent(
        "Meeting",
        "2025-04-10T10:00",
        "2025-04-10T11:00",
        "Discuss project",
        "Office",
        true,
        false);
    assertEquals("Event created: Meeting", createResult);

    String editResult = controller.editEvent(
        "Meeting",
        "2025-04-10T10:00",
        "subject",
        "UpdatedMeeting",
        "SINGLE");

    assertTrue(editResult.contains("Edited event(s) 'Meeting': subject changed to UpdatedMeeting"));
  }

  @Test
  public void printEventsOn() {

    controller.createSingleEvent(
        "Lunch",
        "2025-04-11T12:00",
        "2025-04-11T13:00",
        "Lunch with client",
        "Cafe",
        true,
        false);

    LocalDate date = LocalDate.parse("2025-04-11", DateTimeFormatter.ISO_LOCAL_DATE);
    String output = controller.printEventsOn(date);
    assertTrue(output.contains("Events on 2025-04-11:"));
    assertTrue(output.contains("- Lunch at Cafe 2025-04-11T12:00"));
  }

  @Test
  public void exportCalendar() {

    controller.createSingleEvent(
        "ExportMeeting",
        "2025-04-12T09:00",
        "2025-04-12T10:00",
        "Export test",
        "Room 1",
        true,
        false);

    String result = controller.exportCalendar("testCalendar.csv", "csv");

    assertTrue(result.contains("Calendar exported to:"));
  }

  @Test
  public void importCalendar() throws Exception {

    File tempFile = File.createTempFile("testCalendar", ".csv");
    tempFile.deleteOnExit();
    try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile))) {
      writer.write(
          "Subject,Start Date,Start Time,End Date,End Time,"
              + "AllDayEvent,Description,Location,Private");
      writer.newLine();

      writer.write("ImportedEvent,2025-04-10,09:00,2025-04-10,10:00,"
          + "false,ImpDesc,ImpLoc,false");
      writer.newLine();
    }

    String importResult = controller.importCalendar(tempFile.getAbsolutePath());
    assertTrue(importResult.contains("Imported"));
  }

  @Test
  public void editCalendar() {

    controller.createCalendar("MyCalendar", "UTC");

    String result = controller.editCalendar("MyCalendar", "name", "UpdatedMyCalendar");
    assertEquals("Calendar name updated to: UpdatedMyCalendar", result);

    String tzResult = controller.editCalendar("UpdatedMyCalendar", "timezone", "America/New_York");
    assertEquals("Calendar timezone updated to: America/New_York", tzResult);
  }

  @Test
  public void getCurrentCalendarNameAndZone() throws Exception {

    controller.createCalendar("TestCal", "Asia/Tokyo");
    controller.useCalendar("TestCal");
    String[] info = controller.getCurrentCalendarNameAndZone();
    assertNotNull(info);
    assertEquals(2, info.length);
    assertEquals("TestCal", info[0]);

    assertTrue(info[1].contains("Asia/Tokyo"));
  }

  @Test
  public void start() {
    try {
      controller.start();
    } catch (Exception ex) {
      fail("Just for coverage, this should not throw any exceptions " + ex.getMessage());
    }
  }


  @Test
  public void exportWithUnsupportedFormat() {
    String result = controller.exportCalendar("test.xyz", "xyz");
    assertTrue(result.contains("Error exporting calendar"));
  }

  @Test
  public void editCalendarInvalidProperty() {
    String result = controller.editCalendar("Default", "color", "blue");
    assertEquals("Unknown calendar property: color", result);
  }


}
--- End of file: controller\GUIControllerTest.java ---


--- Start of file: controller\GUICreateCalendarParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * Test Cases for the {@link GUICreateCalendarParser} class.
 */
public class GUICreateCalendarParserTest {

  private GUICreateCalendarParser parser;

  /**
   * Initializes the calendar service and parser before each test.
   */
  @Before
  public void setUp() {
    ICalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    parser = new GUICreateCalendarParser(service);
  }

  @Test
  public void parseValidCreation() {

    String calendarName = "TestCalendar";
    String timezone = "UTC";
    Command command = parser.parse(calendarName, timezone);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Calendar created: " + calendarName, result);
  }

  @Test
  public void parseDuplicateCreation() {

    String calendarName = "TestCalendarDup";
    String timezone = "UTC";
    Command command1 = parser.parse(calendarName, timezone);
    String result1 = "";
    try {
      result1 = command1.execute();
    } catch (Exception e) {
      fail("Execution threw an exception on first creation: " + e.getMessage());
    }
    assertEquals("Calendar created: " + calendarName, result1);

    Command command2 = parser.parse(calendarName, timezone);
    String result2 = "";
    try {
      result2 = command2.execute();
    } catch (Exception e) {
      fail("Execution threw an exception on duplicate creation: " + e.getMessage());
    }
    assertEquals("Calendar creation failed: Duplicate calendar name.", result2);
  }

  @Test
  public void parseInvalidTimezone() {

    String calendarName = "InvalidTimeZoneCalendar";
    String invalidTimezone = "invalid";
    Command command = parser.parse(calendarName, invalidTimezone);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception with invalid timezone: " + e.getMessage());
    }

    assertTrue(result.startsWith("Calendar creation failed:"));
    assertTrue(result.contains("Invalid timezone"));
  }
}
--- End of file: controller\GUICreateCalendarParserTest.java ---


--- Start of file: controller\GUICreateRecurringEventParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * A test case to verify the Parsing of the {@link GUICreateRecurringEventParserTest} which parse
 * recurring events for the GUI.
 */
public class GUICreateRecurringEventParserTest {

  private GUICreateRecurringEventParser parser;

  @Before
  public void setUp() throws Exception {

    ICalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);
    service.createCalendar("ABC", "UTC");
    service.useCalendar("ABC");

    parser = new GUICreateRecurringEventParser(service);


  }

  @Test
  public void testValidRecurringCreationWithOccurrenceCount() {

    String subject = "WeeklyMeeting";
    String start = "2025-04-10T10:00";
    String end = "2025-04-10T11:00";
    String description = "Team sync";
    String location = "Conference Room";
    boolean isPublic = true;
    String recurrenceDays = "MWF";
    String occurrenceCount = "3";
    String recurrenceEndDate = "";
    boolean autoDecline = false;

    Command command = parser.parse(subject, start, end, description, location, isPublic,
        recurrenceDays, occurrenceCount, recurrenceEndDate, autoDecline);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Recurring event created: " + subject, result);
  }

  @Test
  public void testValidRecurringCreationWithRecurrenceEndDate() {

    String subject = "DailyRoutine";
    String start = "2025-04-10T08:00";
    String end = "2025-04-10T09:00";
    String description = "Morning workout";
    String location = "Gym";
    boolean isPublic = false;
    String recurrenceDays = "MTWRF";
    String occurrenceCount = "";
    String recurrenceEndDate = "2025-04-20";
    boolean autoDecline = false;

    Command command = parser.parse(subject, start, end, description, location, isPublic,
        recurrenceDays, occurrenceCount, recurrenceEndDate, autoDecline);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Recurring event created: " + subject, result);
  }

  @Test
  public void testErrorWhenNoOccurrenceCountOrRecurrenceEndProvided() {

    String subject = "InvalidEvent";
    String start = "2025-04-10T10:00";
    String end = "2025-04-10T11:00";
    String description = "Invalid case";
    String location = "Office";
    boolean isPublic = true;
    String recurrenceDays = "MWF";
    String occurrenceCount = "";
    String recurrenceEndDate = "";
    boolean autoDecline = false;

    Command command = parser.parse(subject, start, end, description, location, isPublic,
        recurrenceDays, occurrenceCount, recurrenceEndDate, autoDecline);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Error: Either occurrence count or recurrence end date must be provided.", result);
  }

  @Test
  public void testErrorWithNonNumericOccurrenceCount() {

    String subject = "NonNumericEvent";
    String start = "2025-04-10T10:00";
    String end = "2025-04-10T11:00";
    String description = "Test non numeric occurrence count";
    String location = "Office";
    boolean isPublic = true;
    String recurrenceDays = "MWF";
    String occurrenceCount = "abc";
    String recurrenceEndDate = "";
    boolean autoDecline = false;

    Command command = parser.parse(subject, start, end, description, location, isPublic,
        recurrenceDays, occurrenceCount, recurrenceEndDate, autoDecline);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }

    assertEquals("Error: Occurrence count must be numeric.", result);
  }

  @Test
  public void testErrorWithEmptySubject() {

    String subject = "";
    String start = "2025-04-10T10:00";
    String end = "2025-04-10T11:00";
    String description = "Test empty subject";
    String location = "Office";
    boolean isPublic = true;
    String recurrenceDays = "MWF";
    String occurrenceCount = "3";
    String recurrenceEndDate = "";
    boolean autoDecline = false;

    Command command = parser.parse(subject, start, end, description, location, isPublic,
        recurrenceDays, occurrenceCount, recurrenceEndDate, autoDecline);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception during empty subject test: " + e.getMessage());
    }
    assertEquals("Error: Subject cannot be empty.", result);
  }

  @Test
  public void testErrorWithEmptyStart() {

    String subject = "ValidSubject";
    String start = "";
    String end = "2025-04-10T11:00";
    String description = "Test empty start";
    String location = "Office";
    boolean isPublic = true;
    String recurrenceDays = "MWF";
    String occurrenceCount = "3";
    String recurrenceEndDate = "";
    boolean autoDecline = false;

    Command command = parser.parse(subject, start, end, description, location, isPublic,
        recurrenceDays, occurrenceCount, recurrenceEndDate, autoDecline);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception during empty start test: " + e.getMessage());
    }
    assertEquals("Error: Start time is required.", result);
  }

  @Test
  public void testErrorWithEmptyRecurrenceDays() {

    String subject = "ValidSubject";
    String start = "2025-04-10T10:00";
    String end = "2025-04-10T11:00";
    String description = "Test empty recurrence days";
    String location = "Office";
    boolean isPublic = true;
    String recurrenceDays = "";
    String occurrenceCount = "3";
    String recurrenceEndDate = "";
    boolean autoDecline = false;

    Command command = parser.parse(subject, start, end, description, location, isPublic,
        recurrenceDays, occurrenceCount, recurrenceEndDate, autoDecline);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception during empty recurrence days test: " + e.getMessage());
    }
    assertEquals("Error: Recurrence days are required.", result);
  }

}
--- End of file: controller\GUICreateRecurringEventParserTest.java ---


--- Start of file: controller\GUICreateSingleEventParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * JUNIT Test Class for {@link GUICreateSingleEventParserTest} which parses SingleEvents.
 */
public class GUICreateSingleEventParserTest {

  private GUICreateSingleEventParser parser;

  @Before
  public void setUp() throws Exception {

    ICalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);

    service.createCalendar("Default", "UTC");
    service.useCalendar("Default");
    parser = new GUICreateSingleEventParser(service);
  }

  @Test
  public void testValidSingleEventCreation() {
    String subject = "Meeting";
    String start = "2025-04-10T10:00";
    String end = "2025-04-10T11:00";
    String description = "Project meeting";
    String location = "Conference Room";
    boolean isPublic = true;
    boolean autoDecline = false;

    Command command = parser.parse(subject, start, end, description, location, isPublic,
        autoDecline);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Event created: " + subject, result);
  }

  @Test
  public void testEmptySubject() {
    String subject = "";
    String start = "2025-04-10T10:00";
    String end = "2025-04-10T11:00";
    String description = "Some description";
    String location = "Room 1";
    boolean isPublic = true;
    boolean autoDecline = false;

    Command command = parser.parse(subject, start, end, description, location, isPublic,
        autoDecline);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Error: Subject cannot be empty.", result);
  }

  @Test
  public void testEmptyStart() {
    String subject = "Meeting";
    String start = "";
    String end = "2025-04-10T11:00";
    String description = "Some description";
    String location = "Room 1";
    boolean isPublic = true;
    boolean autoDecline = false;

    Command command = parser.parse(subject, start, end, description, location, isPublic,
        autoDecline);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Error: Start time is required.", result);
  }

  @Test
  public void testInvalidStartDate() {
    String subject = "Meeting";
    String start = "invalidDate";
    String end = "2025-04-10T11:00";
    String description = "Some description";
    String location = "Room 1";
    boolean isPublic = true;
    boolean autoDecline = false;

    Command command = parser.parse(subject, start, end, description, location, isPublic,
        autoDecline);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }

    assertTrue(result.startsWith("Error parsing start date/time:"));
  }

  @Test
  public void testDefaultEndWhenEmpty() {

    String subject = "Meeting";
    String start = "2025-04-10T10:00";
    String end = "";
    String description = "Some description";
    String location = "Room 1";
    boolean isPublic = true;
    boolean autoDecline = false;

    Command command = parser.parse(subject, start, end, description, location, isPublic,
        autoDecline);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }

    assertEquals("Event created: " + subject, result);
  }

}
--- End of file: controller\GUICreateSingleEventParserTest.java ---


--- Start of file: controller\GUICSVExportCalendarParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.nio.file.Paths;
import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

/**
 * JUNIT Test Class for {@link GUICSVExportCalendarParser} which parses CSV formats.
 */
public class GUICSVExportCalendarParserTest {

  private GUICSVExportCalendarParser parser;
  private String exportFileName;


  @Before
  public void setUp() throws Exception {

    ICalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);

    service.createCalendar("Default", "UTC");
    service.useCalendar("Default");

    parser = new GUICSVExportCalendarParser(service);
    exportFileName = "testExport.csv";

    File file = new File(Paths.get(System.getProperty("user.dir"), exportFileName).toString());
    if (file.exists()) {
      file.delete();
    }
  }

  @After
  public void tearDown() throws Exception {

    File file = new File(Paths.get(System.getProperty("user.dir"), exportFileName).toString());
    if (file.exists()) {
      file.delete();
    }
  }

  @Test
  public void testExportWithCsvExtension() {

    Command command = parser.parse(exportFileName);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }

    assertTrue(result.startsWith("Calendar exported to:"));

    File file = new File(Paths.get(System.getProperty("user.dir"), exportFileName).toString());
    assertTrue(file.exists());

    try (BufferedReader br = new BufferedReader(new FileReader(file))) {
      String header = br.readLine();
      String expectedHeader = "Subject,Start Date,Start Time,End Date,End Time,"
          + "AllDayEvent,Description,Location,Private";
      assertEquals(expectedHeader, header);
    } catch (Exception e) {
      fail("Failed to read exported file: " + e.getMessage());
    }
  }

  @Test
  public void testExportWithoutExtension() {

    String fileNameNoExt = "testExportNoExt";

    Command command = parser.parse(fileNameNoExt);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertTrue(result.startsWith("Calendar exported to:"));

    File file = new File(Paths.get(System.getProperty("user.dir"), fileNameNoExt).toString());
    assertTrue(file.exists());

    file.delete();
  }
}
--- End of file: controller\GUICSVExportCalendarParserTest.java ---


--- Start of file: controller\GUIEditCalendarParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * JUNIT Test Class for {@link GUIEditCalendarParser} which parses Edit Inputs for the Calendar.
 */
public class GUIEditCalendarParserTest {

  private IMultiCalendarService service;
  private GUIEditCalendarParser parser;

  @Before
  public void setUp() throws Exception {

    ICalendarManager manager = new CalendarManager();
    service = new MultiCalendarService(manager);

    service.createCalendar("TestCal", "UTC");
    service.useCalendar("TestCal");

    parser = new GUIEditCalendarParser(service);


  }

  @Test
  public void testValidNameEdit() {

    Command cmd = parser.parse("TestCal", "name", "NewTestCal");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }

    assertEquals("Calendar name updated to: NewTestCal", result);
  }

  @Test
  public void testValidTimezoneEdit() {

    Command cmd = parser.parse("TestCal", "timezone", "Europe/London");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }

    assertEquals("Calendar timezone updated to: Europe/London", result);
  }

  @Test
  public void testUnknownPropertyEdit() {

    Command cmd = parser.parse("TestCal", "unknownProp", "SomeValue");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Unknown calendar property: unknownProp", result);
  }

  @Test
  public void testEmptyCalendarName() {

    Command cmd = parser.parse("", "name", "NewName");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Error: Calendar name cannot be empty.", result);
  }

  @Test
  public void testEmptyProperty() {

    Command cmd = parser.parse("TestCal", "", "NewValue");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Error: Calendar property cannot be empty.", result);
  }

  @Test
  public void testEmptyNewValue() {

    Command cmd = parser.parse("TestCal", "name", "");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Error: New value cannot be empty.", result);
  }

  @Test
  public void testEditWithDuplicateName() throws Exception {

    service.createCalendar("ExistingCal", "UTC");

    Command cmd = parser.parse("TestCal", "name", "ExistingCal");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Calendar name already exists or edit failed.", result);
  }

}
--- End of file: controller\GUIEditCalendarParserTest.java ---


--- Start of file: controller\GUIEditEventParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * Unit tests for the GUIEditEventParser class.
 */
public class GUIEditEventParserTest {

  private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern(
      "yyyy-MM-dd'T'HH:mm");
  private GUIEditEventParser parser;

  /**
   * Prepares a default calendar and adds a single event before each test runs.
   */
  @Before
  public void setUp() throws Exception {

    ICalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);

    service.createCalendar("Default", "UTC");
    service.useCalendar("Default");

    service.addSingleEvent("Meeting",
        LocalDateTime.parse("2025-04-10T10:00", FORMATTER),
        LocalDateTime.parse("2025-04-10T11:00", FORMATTER),
        "Team meeting", "Office", true, false);

    parser = new GUIEditEventParser(service);
  }

  /**
   * Tests successful name update for an existing calendar.
   */
  @Test
  public void testValidEditEventSingleMode() {

    Command cmd = parser.parse("Meeting", "2025-04-10T10:00", "subject", "UpdatedMeeting",
        "SINGLE");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Valid edit event threw an exception: " + e.getMessage());
    }

    assertEquals("Edited event(s) 'Meeting': subject changed to UpdatedMeeting", result);
  }

  @Test
  public void testEmptySubject() {
    Command cmd = parser.parse("", "2025-04-10T10:00", "subject", "NewValue", "SINGLE");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Error: Subject cannot be empty.", result);
  }

  @Test
  public void testEmptyProperty() {
    Command cmd = parser.parse("Meeting", "2025-04-10T10:00", "", "NewValue", "SINGLE");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Error: Property cannot be empty.", result);
  }

  @Test
  public void testEmptyNewValue() {
    Command cmd = parser.parse("Meeting", "2025-04-10T10:00", "subject", "", "SINGLE");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Error: New value cannot be empty.", result);
  }

  @Test
  public void testInvalidEditMode() {

    Command cmd = parser.parse("Meeting", "2025-04-10T10:00", "subject", "NewValue",
        "INVALID_MODE");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Error: Invalid EditMode: INVALID_MODE", result);
  }

  @Test
  public void testMissingStartTimeForSingleMode() {

    Command cmd = parser.parse("Meeting", "", "subject", "NewValue", "SINGLE");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Error: Start time is required for SINGLE or FROM mode.", result);
  }

  @Test
  public void testInvalidStartTimeFormat() {

    Command cmd = parser.parse("Meeting", "invalidTime", "subject", "NewValue", "SINGLE");
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }

    assertTrue(result.startsWith("Error parsing start time:"));
  }

}
--- End of file: controller\GUIEditEventParserTest.java ---


--- Start of file: controller\GUIExportFactoryTest.java ---

package controller;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * Test for the GUIExportFactory, which is a factory of Export Parsers, to see if the correct Parser
 * is returned.
 */
public class GUIExportFactoryTest {

  private IMultiCalendarService service;

  @Before
  public void setUp() {
    ICalendarManager manager = new CalendarManager();
    service = new MultiCalendarService(manager);
  }

  @Test
  public void testGetParserCsv() {

    IGUIExporterParser parser = GUIExportFactory.getParser("csv", service);
    assertNotNull(parser);
    assertTrue(parser instanceof GUICSVExportCalendarParser);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testGetParserEmptyFormat() {

    GUIExportFactory.getParser("", service);
  }

  @Test
  public void testGetParserUnsupportedFormat() {

    try {
      GUIExportFactory.getParser("json", service);
      fail("Expected IllegalArgumentException for unsupported format.");
    } catch (IllegalArgumentException e) {
      assertTrue(e.getMessage().contains("Unsupported export format"));
    }
  }

}
--- End of file: controller\GUIExportFactoryTest.java ---


--- Start of file: controller\GUIImportCSVCalendarParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertTrue;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * JUnit Test Cases for {@link GUIImportCSVCalendarParser}.
 */
public class GUIImportCSVCalendarParserTest {

  private GUIImportCSVCalendarParser parser;


  @Before
  public void setUp() throws Exception {

    ICalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);

    service.createCalendar("Default", "UTC");
    service.useCalendar("Default");
    parser = new GUIImportCSVCalendarParser(service);
  }

  @Test
  public void testNullFileName() throws Exception {
    Command cmd = parser.parse(null);
    String result = cmd.execute();
    assertEquals("Error: File name cannot be empty.", result);
  }

  @Test
  public void testEmptyFileName() throws Exception {
    Command cmd = parser.parse("   ");
    String result = cmd.execute();
    assertEquals("Error: File name cannot be empty.", result);
  }

  @Test
  public void testValidCSVImport() throws Exception {

    File tempFile = File.createTempFile("testImport", ".csv");
    tempFile.deleteOnExit();
    String filePath = tempFile.getAbsolutePath();
    try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile))) {

      writer.write(
          "Subject,Start Date,Start Time,End Date,"
              + "End Time,AllDayEvent,Description,Location,Private");
      writer.newLine();

      writer.write("ImportEvent,2025-04-10,09:00,2025-04-10,10:00,false,Desc,Loc,false");
      writer.newLine();
    }

    Command cmd = parser.parse(filePath);
    String result = cmd.execute();

    assertTrue(result.contains("Imported"));
  }

  @Test
  public void testInvalid2() throws Exception {
    String trailingDotFileName = "data.";
    Command cmdTrailing = parser.parse(trailingDotFileName);
    String resultTrailing;
    try {
      resultTrailing = cmdTrailing.execute();
    } catch (Exception e) {
      resultTrailing = e.getMessage();
    }
    assertTrue(resultTrailing.contains("data.") || resultTrailing.contains("Error"));

  }

  @Test
  public void testInvalid3() throws Exception {
    File tempFile = File.createTempFile("testImportUpper", ".CSV");
    tempFile.deleteOnExit();
    try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile))) {
      writer.write(
          "Subject,Start Date,Start Time,End Date,End Time,"
              + "AllDayEvent,Description,Location,Private");
      writer.newLine();
      writer.write("TestEvent,2025-04-10,09:00,2025-04-10,10:00,false,Desc,Loc,false");
      writer.newLine();
    }
    Command cmdUpper = parser.parse(tempFile.getAbsolutePath());
    String resultUpper = cmdUpper.execute();
    assertTrue(resultUpper.contains("Imported"));
  }


}
--- End of file: controller\GUIImportCSVCalendarParserTest.java ---


--- Start of file: controller\GUIImportFactoryTest.java ---

package controller;

import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * JUNIT Test case for {@link GUIImportFactory}, which is a factory of different format of Import
 * Parsers.
 */
public class GUIImportFactoryTest {

  private IMultiCalendarService service;

  @Before
  public void setUp() {

    ICalendarManager manager = new CalendarManager();
    service = new MultiCalendarService(manager);
  }

  @Test
  public void testGetParserCsv() {

    Object parser = GUIImportFactory.getParser("csv", service);
    assertNotNull("Parser should not be null for 'csv' format", parser);
    assertTrue("Parser should be an instance of GUIImportCSVCalendarParser",
        parser instanceof GUIImportCSVCalendarParser);
  }

  @Test(expected = IllegalArgumentException.class)
  public void testEmptyFormatThrowsException() {

    GUIImportFactory.getParser("", service);
  }

  @Test
  public void testUnsupportedFormatThrowsException() {
    try {
      GUIImportFactory.getParser("xml", service);
      fail("Expected IllegalArgumentException for unsupported import format.");
    } catch (IllegalArgumentException ex) {
      assertTrue(ex.getMessage().contains("Unsupported import format"));
    }
  }

}
--- End of file: controller\GUIImportFactoryTest.java ---


--- Start of file: controller\GUIPrintEventsParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;

import java.time.LocalDate;
import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * Tests for the GUIPrintEventsParser class. These will check that event printing commands are
 * properly parsed.
 */
public class GUIPrintEventsParserTest {

  private GUIPrintEventsParser parser;

  @Before
  public void setUp() throws Exception {

    ICalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);

    service.createCalendar("Default", "UTC");
    service.useCalendar("Default");

    parser = new GUIPrintEventsParser(service);
  }

  @Test
  public void testParseNullDate() throws Exception {

    Command cmd = parser.parse(null);
    String result = cmd.execute();
    assertEquals("Error: Date is required.", result);
  }

  @Test
  public void testParseValidDateWithNoEvents() throws Exception {

    LocalDate date = LocalDate.of(2025, 4, 10);
    Command cmd = parser.parse(date);
    String result = cmd.execute();

    assertEquals("", result);
  }

}
--- End of file: controller\GUIPrintEventsParserTest.java ---


--- Start of file: controller\GUIUseCalendarParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * Tests for GUIUseCalendarParser. Verifies whether the Calendar is being used or not.
 */
public class GUIUseCalendarParserTest {

  private IMultiCalendarService service;
  private GUIUseCalendarParser parser;

  @Before
  public void setUp() throws Exception {

    ICalendarManager manager = new CalendarManager();
    service = new MultiCalendarService(manager);

    service.createCalendar("Default", "UTC");
    service.useCalendar("Default");

    parser = new GUIUseCalendarParser(service);
  }

  @Test
  public void testUseExistingCalendar() throws Exception {

    String calendarName = "TestCalendar";
    service.createCalendar(calendarName, "UTC");

    Command cmd = parser.parse(calendarName);
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Using calendar: " + calendarName, result);
  }

  @Test
  public void testUseNonExistingCalendar() throws Exception {

    String calendarName = "NonExistingCalendar";
    Command cmd = parser.parse(calendarName);
    String result = "";
    try {
      result = cmd.execute();
    } catch (Exception e) {
      fail("Execution threw an exception: " + e.getMessage());
    }
    assertEquals("Calendar not found: " + calendarName, result);
  }
}
--- End of file: controller\GUIUseCalendarParserTest.java ---


--- Start of file: controller\HeadCommandParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import model.CalendarModel;
import model.CalendarService;
import model.ICalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * JUnit Test Case for {@link HeadCommandParser}, which delegates the arguments to other dedicated
 * parsers based on the arguments provided.
 */

public class HeadCommandParserTest {

  private HeadCommandParser parser;

  @Before
  public void setUp() {
    CalendarModel calendar = new CalendarModel();
    ICalendarService service = new CalendarService(calendar);
    parser = new HeadCommandParser(service);
  }

  @Test
  public void testUnknownCommand() throws Exception {
    Command cmd = parser.parse("eprnig command");
    String result = cmd.execute();
    assertEquals("Unknown command.", result);
  }

  @Test
  public void testErrorProcessingInParse() throws Exception {
    Command cmd = parser.parse("create event Meeting from invalidDate to 2025-03-01T10:00");
    String result = cmd.execute();
    assertTrue(result.startsWith("Error processing create command:"));
  }

  @Test
  public void testEmptyInputReturnsNull() {
    Command cmd = parser.parse("    ");
    assertNull(cmd);
  }

  @Test
  public void testNullInputReturnsNull() {
    Command cmd = parser.parse(null);
    assertNull(cmd);
  }

}
--- End of file: controller\HeadCommandParserTest.java ---


--- Start of file: controller\ImportCalendarCommandTest.java ---

package controller;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.nio.file.Paths;
import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

/**
 * Tests for the ImportCalendarCommand class.
 */
public class ImportCalendarCommandTest {

  private IMultiCalendarService service;
  private File tempFile;
  private String tempFilePath;

  /**
   * Prepares the calendar system and a temporary CSV file with a valid row before each test.
   */
  @Before
  public void setUp() throws Exception {

    ICalendarManager manager = new CalendarManager();
    service = new MultiCalendarService(manager);

    service.createCalendar("Default", "UTC");
    service.useCalendar("Default");

    tempFile = File.createTempFile("testImport", ".csv");
    tempFilePath = tempFile.getAbsolutePath();
    try (BufferedWriter writer = new BufferedWriter(new FileWriter(tempFile))) {

      writer.write(
          "Subject,Start Date,Start Time,End Date,"
              + "End Time,AllDayEvent,Description,Location,Private");
      writer.newLine();

      writer.write("ImportedEvent,2025-04-10,09:00,2025-04-10,10:00,false,Desc,Loc,false");
      writer.newLine();
    }
  }

  @After
  public void tearDown() throws Exception {

    if (tempFile != null && tempFile.exists()) {
      tempFile.delete();
    }
  }

  @Test
  public void testSuccessfulImport() {

    ImportCalendarCommand command = new ImportCalendarCommand(service, "csv", tempFilePath);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Command execution threw an exception: " + e.getMessage());
    }

    assertTrue(
        result.toLowerCase().contains("imported"));
  }

  @Test
  public void testImportFileNotFound() {

    String nonExistentPath = Paths.get(System.getProperty("user.dir"), "nonexistentfile.csv")
        .toString();
    ImportCalendarCommand command = new ImportCalendarCommand(service, "csv", nonExistentPath);
    String result = "";
    try {
      result = command.execute();
    } catch (Exception e) {
      fail("Command execution threw an exception: " + e.getMessage());
    }

    assertTrue(
        result.startsWith("Import failed:"));
  }
}
--- End of file: controller\ImportCalendarCommandTest.java ---


--- Start of file: controller\PrintEventsCommandTest.java ---

package controller;

import static org.junit.Assert.assertTrue;

import java.time.LocalDate;
import java.time.LocalDateTime;
import model.CalendarModel;
import model.CalendarService;
import model.ICalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * JUnit Test Cases for PrintEventsCommandTest.
 */
public class PrintEventsCommandTest {

  ICalendarService calendar;

  @Before
  public void setUp() throws Exception {
    CalendarModel calendara = new CalendarModel();
    calendar = new CalendarService(calendara);
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    calendar.addSingleEvent("Meeting", start, end, "", "", true, false);
  }

  /**
   * Tests that the PrintEventsCommand correctly prints events for a given date.
   */
  @Test
  public void testPrintEvents() throws Exception {
    LocalDate date = LocalDate.of(2025, 3, 1);
    PrintEventsCommand cmd = new PrintEventsCommand(calendar, date);
    String output = cmd.execute();
    assertTrue(output.contains("Meeting"));
    assertTrue(output.contains("2025-03-01T09:00"));
  }
}
--- End of file: controller\PrintEventsCommandTest.java ---


--- Start of file: controller\PrintEventsRangeCommandTest.java ---

package controller;

import static org.junit.Assert.assertTrue;

import java.time.LocalDateTime;
import model.CalendarModel;
import model.CalendarService;
import model.ICalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * Tests for the PrintEventsRangeCommand class. This verifies that events scheduled within a
 * specific time window are printed correctly by the command.
 */

public class PrintEventsRangeCommandTest {

  private ICalendarService calendar;


  @Before
  public void setUp() throws Exception {
    CalendarModel calendara = new CalendarModel();
    calendar = new CalendarService(calendara);
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    calendar.addSingleEvent("Meeting", start, end, "", "", true, false);
  }

  /**
   * Tests that the PrintEventsRangeCommand correctly prints events within the specified range.
   */
  @Test
  public void testPrintEventsRange() throws Exception {
    String startStr = "2025-03-01T00:00";
    String endStr = "2025-03-02T00:00";
    PrintEventsRangeCommand cmd = new PrintEventsRangeCommand(calendar, startStr, endStr);
    String output = cmd.execute();
    assertTrue(output.contains("Meeting"));
  }
}

--- End of file: controller\PrintEventsRangeCommandTest.java ---


--- Start of file: controller\ShowStatusCommandParserTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import model.CalendarModel;
import model.CalendarService;
import model.ICalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * Tests for the ShowStatusCommandParser class.
 */
public class ShowStatusCommandParserTest {

  private ShowStatusCommandParser parser;

  /**
   * Sets up the test fixture before each test.
   */
  @Before
  public void setUp() {
    CalendarModel calendar = new CalendarModel();
    ICalendarService calendarService = new CalendarService(calendar);
    parser = new ShowStatusCommandParser(calendarService);
  }


  @Test
  public void testValidShowStatusCommand() throws Exception {
    String[] tokens = "show status on 2025-03-01T09:30".split("\\s+");
    Command cmd = parser.parse(tokens);
    String result = cmd.execute();
    assertTrue(result.equals("Busy") || result.equals("Available"));
  }


  @Test
  public void testInvalidShowCommandTooFewTokens() throws Exception {
    String[] tokens = "show status".split("\\s+");
    Command cmd = parser.parse(tokens);
    String result = cmd.execute();
    assertEquals("Invalid show command.", result);
  }


  @Test
  public void testInvalidShowCommandWrongKeywords() throws Exception {
    String[] tokens1 = "show stat on 2025-03-01T09:30".split("\\s+");
    Command cmd1 = parser.parse(tokens1);
    assertNotNull(cmd1);
    String result1 = cmd1.execute();
    assertEquals("Invalid show command.", result1);

    String[] tokens2 = "show status off 2025-03-01T09:30".split("\\s+");
    Command cmd2 = parser.parse(tokens2);
    assertNotNull(cmd2);
    String result2 = cmd2.execute();
    assertEquals("Invalid show command.", result2);
  }


  @Test
  public void testShowCommandInvalidDateTime() throws Exception {
    String[] tokens = "show status on invalidDate".split("\\s+");
    Command cmd = parser.parse(tokens);
    assertNotNull(cmd);
    String result = cmd.execute();
    assertTrue(result.startsWith("Error processing show command:"));
  }
}
--- End of file: controller\ShowStatusCommandParserTest.java ---


--- Start of file: controller\ShowStatusCommandTest.java ---

package controller;

import static org.junit.Assert.assertEquals;

import java.time.LocalDateTime;
import model.CalendarModel;
import model.CalendarService;
import model.ICalendarService;
import org.junit.Before;
import org.junit.Test;

/**
 * Unit tests for the ShowStatusCommand class.
 */
public class ShowStatusCommandTest {

  private ICalendarService calendar;

  @Before
  public void setUp() throws Exception {
    CalendarModel calendara = new CalendarModel();
    calendar = new CalendarService(calendara);
    LocalDateTime start = LocalDateTime.of(2025, 3, 1, 9, 0);
    LocalDateTime end = LocalDateTime.of(2025, 3, 1, 10, 0);
    calendar.addSingleEvent("Meeting", start, end, "", "", true, false);
  }

  /**
   * Tests that the status is "Busy" when the check time falls within an event.
   */
  @Test
  public void testShowStatusBusy() {
    LocalDateTime checkTime = LocalDateTime.of(2025, 3, 1, 9, 30);
    ShowStatusCommand cmd = new ShowStatusCommand(calendar, checkTime);
    String result = cmd.execute();
    assertEquals("Busy", result);
  }

  /**
   * Tests that the status is "Available" when the check time does not fall within any event.
   */
  @Test
  public void testShowStatusAvailable() {
    LocalDateTime checkTime = LocalDateTime.of(2025, 3, 1, 10, 30);
    ShowStatusCommand cmd = new ShowStatusCommand(calendar, checkTime);
    String result = cmd.execute();
    assertEquals("Available", result);
  }
}

--- End of file: controller\ShowStatusCommandTest.java ---


--- Start of file: controller\TextBasedControllerTest.java ---

package controller;

import static org.junit.Assert.assertTrue;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileWriter;
import java.io.InputStream;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import model.CalendarManager;
import model.ICalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;

/**
 * Tests for the {@link TextBasedController} class, which is for CLI arguments.
 */
public class TextBasedControllerTest {

  private final PrintStream originalOut = System.out;
  private final InputStream originalIn = System.in;
  private ByteArrayOutputStream outContent;

  private IMultiCalendarService service;

  /**
   * Sets up the calendar service and redirects System.out for output capture.
   */
  @Before
  public void setUp() throws Exception {

    outContent = new ByteArrayOutputStream();
    System.setOut(new PrintStream(outContent));

    ICalendarManager manager = new CalendarManager();
    service = new MultiCalendarService(manager);

    service.createCalendar("Default", "UTC");
    service.useCalendar("Default");
  }

  @After
  public void tearDown() throws Exception {
    System.setOut(originalOut);
    System.setIn(originalIn);
  }

  @Test
  public void testInvalidArguments() {

    String[] args = {};
    TextBasedController controller = new TextBasedController(service, args);
    controller.start();
    String output = outContent.toString();
    assertTrue(output.contains("Invalid arguments for text mode."));
  }

  @Test
  public void testHeadlessNoCommandFile() {

    String[] args = {"--mode", "headless"};
    outContent.reset();
    TextBasedController controller = new TextBasedController(service, args);
    controller.start();
    String output = outContent.toString();
    assertTrue(output.contains("Headless mode requires a command file."));
  }

  @Test
  public void testHeadlessFileNotFound() {

    String nonExistentPath = Paths.get(System.getProperty("user.dir"), "nonexistentfile.txt")
        .toString();
    String[] args = {"--mode", "headless", nonExistentPath};
    outContent.reset();
    TextBasedController controller = new TextBasedController(service, args);
    controller.start();
    String output = outContent.toString();
    assertTrue(output.contains("Command file not found: " + nonExistentPath));
  }

  @Test
  public void testHeadlessWithCommands() throws Exception {

    File tempFile = File.createTempFile("commands", ".txt");
    tempFile.deleteOnExit();
    try (FileWriter writer = new FileWriter(tempFile)) {
      writer.write("unknowncommand\n");
      writer.write("exit\n");
    }
    String filePath = tempFile.getAbsolutePath();
    String[] args = {"--mode", "headless", filePath};
    outContent.reset();
    TextBasedController controller = new TextBasedController(service, args);
    controller.start();
    String output = outContent.toString();

    assertTrue(output.contains("Unknown command."));
    tempFile.delete();
  }

  @Test
  public void testInteractiveMode() {
    String inp = "exit\n";
    ByteArrayInputStream inContent = new ByteArrayInputStream(inp.getBytes(
        StandardCharsets.UTF_8));
    System.setIn(inContent);

    String[] args = {"--mode", "interactive"};
    outContent.reset();
    TextBasedController controller = new TextBasedController(service, args);
    controller.start();
    String output = outContent.toString();

    assertTrue(output.contains("Interactive Calendar App. Type 'exit' to quit."));
    assertTrue(output.contains("> "));
  }
}
--- End of file: controller\TextBasedControllerTest.java ---


--- Start of file: controller\UseCalendarCommandParserTest.java ---

package controller;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;

import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;

/**
 * Test Cases for {@link UseCalendarCommandParser}.
 */
public class UseCalendarCommandParserTest {

  @Test
  public void testValidCommandParse() {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    UseCalendarCommandParser parser = new UseCalendarCommandParser(service);

    String[] input = {"use", "calendar", "--name", "WorkCal"};
    Object command = parser.parse(input);

    assertNotNull(command);
    assertTrue(command instanceof UseCalendarCommand);
  }

  @Test
  public void testInvalidCommandMissingFlag() {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    UseCalendarCommandParser parser = new UseCalendarCommandParser(service);

    String[] input = {"use", "calendar", "WorkCal"};
    Object command = parser.parse(input);

    assertFalse(command instanceof UseCalendarCommand);
  }

  @Test
  public void testInvalidCommandTooShort() {
    IMultiCalendarService service = new MultiCalendarService(new CalendarManager());
    UseCalendarCommandParser parser = new UseCalendarCommandParser(service);

    String[] input = {"use"};
    Object command = parser.parse(input);

    assertFalse(command instanceof UseCalendarCommand);
  }
}


--- End of file: controller\UseCalendarCommandParserTest.java ---


--- Start of file: controller\UseCalendarCommandTest.java ---

package controller;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertTrue;

import model.CalendarContext;
import model.CalendarManager;
import model.IMultiCalendarService;
import model.MultiCalendarService;
import org.junit.Test;

/**
 * JUnit Test Cases for UseCalendarCommandTest.
 */
public class UseCalendarCommandTest {

  @Test
  public void testUseValidCalendar() throws Exception {
    CalendarManager manager = new CalendarManager();
    CalendarContext context = new CalendarContext("MyCal", "Asia/Kolkata");
    manager.addCalendar(context);
    IMultiCalendarService service = new MultiCalendarService(manager);

    UseCalendarCommand cmd = new UseCalendarCommand(service, "MyCal");
    String result = cmd.execute();

    assertEquals("Using calendar: MyCal", result);
    assertEquals("MyCal", manager.getCurrentCalendar().getName());
  }


  @Test
  public void testUseInvalidCalendar() throws Exception {
    CalendarManager manager = new CalendarManager();
    IMultiCalendarService service = new MultiCalendarService(manager);

    UseCalendarCommand cmd = new UseCalendarCommand(service, "GhostCal");
    String result = cmd.execute();

    assertTrue(result.toLowerCase().contains("not found"));
    assertNull(manager.getCurrentCalendar());
  }
}



--- End of file: controller\UseCalendarCommandTest.java ---
